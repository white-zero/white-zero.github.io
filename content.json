{"meta":{"title":"Hexo","subtitle":"","description":"","author":"White Zero","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"git push错误non-fastforward","slug":"git push错误non-fastforward","date":"2020-06-19T03:06:33.104Z","updated":"2020-06-19T03:06:33.104Z","comments":true,"path":"2020/06/19/git push错误non-fastforward/","link":"","permalink":"http://yoursite.com/2020/06/19/git%20push%E9%94%99%E8%AF%AFnon-fastforward/","excerpt":"","text":"问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式： 1，强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 git push -f 2，先把git的东西fetch到你本地然后merge后再push $ git fetch $ git merge 这2句命令等价于 $ git pull","categories":[],"tags":[]},{"title":"git的使用","slug":"git的使用","date":"2020-06-16T09:15:46.000Z","updated":"2020-06-16T10:06:56.738Z","comments":true,"path":"2020/06/16/git的使用/","link":"","permalink":"http://yoursite.com/2020/06/16/git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载安装git vim ~/.gitconfig name email alias(命令的缩写) co=checkout(切换分支) ci=commit st=status pl=pull ps=push dt=difftool(提交代码前对比代码) ca=commit -am(备注信息) b=branch 项目的建立(ssh公钥) ssh-keygen -t rsa -C ‘邮箱地址‘ 一路回车 ls -al (显示所有文件，包括git的隐藏文件) cd .ssh/ ls -al id_rsa:私钥 id_rsa.pub:公钥 cat id_rsa.pub 码云 组织—&gt;新建仓库—&gt;管理—&gt;公钥管理—&gt;添加个人公钥 仓库里复制SSH（不用每次输入账号密码） 回到命令行 cd ls(查看当前文件夹) mkdir doc(新建文件夹)。cd进去 git clone (仓库里的ssh复制接到clone后面) yes cd 到对应的仓库里，可以查看文件 在仓库下， vim .gitignore (忽略一些文件) insert .DS_Store(mac下存储文件夹信息的) node_modules dist *.log(日志，不需要) git st 查看状态 git add . (提交到本地) git ca “备注信息“ (用于代码提交到本地) git push (推送到远程) git在远程和在本地的仓库都新建完成","categories":[],"tags":[]},{"title":"后台管理系统","slug":"后台管理系统","date":"2020-06-16T03:43:01.000Z","updated":"2020-06-16T09:15:18.032Z","comments":true,"path":"2020/06/16/后台管理系统/","link":"","permalink":"http://yoursite.com/2020/06/16/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"https://webthemez.com/demo/insight-free-bootstrap-html5-admin-template/ui-elements.html# (bootstrap免费皮肤) navtop和sidetop 在上面网站中，”Dashboard”—&gt;查看源码—&gt;对应的区域edit as html—&gt;ctrl+c ctrl+v到指定组件中—&gt;修改nav标签为div—&gt;把style去掉—&gt;在网页中，把wrapper中element.style{height: 1000px} 首页 商品 商品管理 品类管理 订单 订单管理 用户 用户管理","categories":[],"tags":[]},{"title":"webpack3.10.0打包配置","slug":"webpack3-10-0打包配置","date":"2020-06-15T06:49:37.000Z","updated":"2020-06-15T10:31:26.655Z","comments":true,"path":"2020/06/15/webpack3-10-0打包配置/","link":"","permalink":"http://yoursite.com/2020/06/15/webpack3-10-0%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"&quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;css-loader&quot;: &quot;^0.28.8&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.2&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;react&quot;: &quot;^16.2.0&quot;, &quot;react-dom&quot;: &quot;^16.2.0&quot;, &quot;react-scripts&quot;: &quot;3.4.1&quot;, &quot;style-loader&quot;: &quot;^0.19.1&quot;, &quot;webpack&quot;: &quot;^3.10.0&quot; &quot;sass-loader&quot;: &quot;^6.0.6&quot;, &quot;node-sass&quot;: &quot;^4.14.1&quot; “font-awesome&quot;: &quot;^4.7.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.7&quot;, 根目录new一个webpack.config.js js 文件打包(react语法的处理) 12345entry: &#39;.&#x2F;src&#x2F;app.jsx&#39;,output: &#123; path: path.resolve(__dirname, &#39;dist&#39;), filename: &quot;app.js&quot;&#125;, html 文件打包 const HtmlWebpackPlugin = require(‘html-webpack-plugin’) 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;)] //temlate是模版。即待打包的html文件 css 文件打包 tips: 要在js文件里import 123456&#123; test: &#x2F;\\.css$&#x2F;, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] - const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) （这个插件可以在打包的文件中，把css独立出来，可以提前加载）代码改为 1234567&#123;test: &#x2F;\\.css$&#x2F;,use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;)&#125; 123456plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;), new ExtractTextPlugin(&quot;index.css&quot;)] sass文件的处理 (一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。) 要同时下载 “sass-loader”: “^6.0.6”,&quot;node-sass&quot;: &quot;^4.14.1&quot; 1234567&#123; test: &#x2F;\\.scss$&#x2F;, use: ExtractTextPlugin.extract(&#123; fallback: &#39;style-loader&#39;, use: [&#39;css-loader&#39;, &#39;sass-loader&#39;] &#125;)&#125;, 图片的打包 下载 url-loader@0.6.2 file-loader@1.1.6 1234567891011&#123;test: &#x2F;\\.(png|jpg|gif)$&#x2F;,use: [ &#123; loader: &quot;url-loader&quot;, options: &#123; limit: 8192 &#125; &#125; ]&#125; 字体图标的配置（npm install font-awesome） 现在js文件中引入 font-awesome/css/font-awesome.min.css 再在webpack.config.js里配置 1234567891011&#123; test: &#x2F;\\.(eot|svg|ttf|woff|woff2|otf)$&#x2F;, use: [ &#123; loader: &#39;url-loader&#39;, options: &#123; limit: 8192 &#125; &#125; ]&#125; 提出公共模块 先 const webpack = require(‘webpack’) 12345678910plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;), new ExtractTextPlugin(&quot;css&#x2F;[name].css&quot;), new webpack.optimize.CommonsChunkPlugin(&#123; name : &#39;common&#39;, filename: &#39;js&#x2F;base.js&#39; &#125;)] webpack-dev-server(页面自动更新，挂载在自定义的端口上) 修改端口 123devServer: &#123; port: 8086,&#125; 在output里加publicPath：“/dist/” (当报错一些字体文件找不到的时候加。) 终端 node_modules/.bin/webpack-dev-server 启动 在package.json里加几个scripts 里的字段 12&quot;dev&quot;: &quot;node_modules&#x2F;.bin&#x2F;webpack-dev-server&quot;,&quot;dist&quot;: &quot;node_modules&#x2F;.bin&#x2F;webpack -p&quot; &#x2F;&#x2F;线上环境时，最好后面加上-p","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-12T07:52:12.741Z","updated":"2020-06-12T07:52:12.741Z","comments":true,"path":"2020/06/12/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"面试","slug":"面试","date":"2020-06-09T05:33:48.000Z","updated":"2020-06-12T07:45:29.693Z","comments":true,"path":"2020/06/09/面试/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95/","excerpt":"HTML HTML语义化 如&lt;Header&gt;代表头部，&lt;nav&gt;代表超链接区域，&lt;main&gt;定义文档主要内容，&lt;article&gt;表示文章博客等，&lt;aside&gt;侧边栏，&lt;footer&gt;底部 就是让页面内容结构化。优点如下 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构 有利于SEO（搜索引擎优化，让更多的用户通过搜索引擎搜到你的网站，让更多人喜欢你的网站），搜索引擎根据标签来确定上下文和各个关键字的权重 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，可读性强 HTML5新标签 &lt;header&gt; &lt;footer&gt; &lt;aside&gt; &lt;nav&gt; &lt;video&gt; &lt;audio&gt; &lt;canvas&gt;等…","text":"HTML HTML语义化 如&lt;Header&gt;代表头部，&lt;nav&gt;代表超链接区域，&lt;main&gt;定义文档主要内容，&lt;article&gt;表示文章博客等，&lt;aside&gt;侧边栏，&lt;footer&gt;底部 就是让页面内容结构化。优点如下 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构 有利于SEO（搜索引擎优化，让更多的用户通过搜索引擎搜到你的网站，让更多人喜欢你的网站），搜索引擎根据标签来确定上下文和各个关键字的权重 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，可读性强 HTML5新标签 &lt;header&gt; &lt;footer&gt; &lt;aside&gt; &lt;nav&gt; &lt;video&gt; &lt;audio&gt; &lt;canvas&gt;等… CSSCSS布局 水平居中 text-align:center对于（文本/行内元素/行内块级元素）相对他的块父级元素对齐。优：简单快捷易理解，兼容性好。缺：只对行内内容有效，属性会继承影响到后代行内的内容，如果子元素宽度大于父元素宽度，则无效。只有于才行 width: 100px; margin: 0 auto; 对于单个块级元素优：简单；兼容性好缺：必须定宽度，且值不能为auto，宽度必须小于父元素 #parent{text-align:center;} .son{display: inline-block; } 多个块级元素，相对他的块父元素对齐 使用绝对定位实现（子绝父相）#parent{height:200px; width:200px; position: relative; }#son{position:absolute; left: 50%; } //top 、right 、bottom、 left的值是相对于父元素尺寸的，margin或transform是相对自身 尺寸的，组合使用达到水平居中的目的 flex(任意个元素)#parent{display: flex; justify-content: center; } 设置当前主轴对齐方式为居中。缺：PC端兼容性问题，移动端（Android4.0+） 水平居中小结- 首先想到`text-align:center`,但其只对行内有效。所以使用时将子元素设为`display: inline` 或 `display: inline-block` - 其次考虑用`margin: 0 auto` 但要记得带上宽度。因为这两种代码量少，再次使用绝对定位去实现。 - 移动端能用flex 垂直居中 #parent{height:100px; line-height:100px;} line-height和height等值。对于单行文本/行内元素/行内块级元素优：简单兼容性好缺：只能用于单行行内内容，且要知道高度的值 多行文本/行内元素/行内块级元素#parent{height: 150px; line-height: 30px; } //元素在页面呈现5行，则line-height的值为height/5优点：简单，兼容性好缺点：只能用于行内内容，需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 图片 （vertical-align和line-height）#parent{height:150px; line-height: 150px; font-size:0 } img#son{vertical-align: middle } //默认是基线对齐，改为middle优点：简单，兼容缺：需要添加font-size:0,才可以完全垂直居中。需要注意，html#parent包裹img之间需要有换行或者空格 单个块级元素html &lt;div id = &quot;parent&quot;&gt;&lt;div id = &quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;(1)使用table-cell实现 #parent{display: table-cell; vertical-align: middle; } 优点： 简单，宽高不定，兼容性 缺点： 设置table-cell的元素。宽度和高度的值设置百分比无效，需要给他的父元素设置display: table才生效, 不感知margin，在父元素上设置table-row等属性，也会使其不感知height,设置float或position会对默认布局造成破坏（考虑为之增加一个父div定义float等属性内容溢出会自动撑开父元素(2)使用绝对定位实现（同水平居中的方式：子绝父相）(3)使用flex实现 #parent{display: flex; align-items: center} 或 #parent{display: flex} #son{align-self: center} 或 #parent{display: flex} #son{margin: auto 0 } 优：简单灵活 缺：PC兼容问题 垂直居中小结- 首先想到line-height，但是只能用于行内内容 - 其次考虑用vertical-align： middle - 绝对定位，代码多了点，但是胜在适用不同情况 - 移动端兼容性允许的情况下能用flex就用flex 水平垂直居中 (1) 行内/行内块级/图片#parent{height: 150px; line-height: 150px; text-align: center; font-size: 0; } #son{vertical: middle} 如果是块级元素，需要在son中加display：inline-block优点：代码简单，兼容（ie8+）缺点：只对行内内容有效； 需要添加font-size: 0; 才可以完全的垂直居中，不过需要注意的是，html中#parent包裹#son之间需要有换行或空格 (2) table-cell 使表格内容垂直对齐方式为middle，然后根据是行内内容还是块级内容采取不同的方式达到水平居中#parent{height:150px; width:200px; display: table-cell; vertical-align: middle; } 如果是行内元素加一行text-align: center#son{width: 100px; height:50px; } 如果是块级元素加一行 margin: 0 auto (3) button作为父元素改掉button的默认样式，再把需要居中的元素表现形式改为行内或行内块级button#parent{height: 150px; width: 200px; outline: none; border: none;} #son{display: inline-block } //button自带text-align：center - (4) 绝对定位 （子绝父相） (5) flex#parent{display: flex} #son{margin: auto } 或 #parent{display: flex; justify-content: center; align-items: center } 或 #parent{display: flex; justify-content: center} #son{align-self: center} (6) 视窗居中（vh为视口单位，视口即文档的可视部分，50vh就是视口高度的50/100，）#son{margin: 50vh auto 0; transform: translateY(-50%)} (7) 绝对居中（子绝父相+ 子元素中top&amp;bottom&amp;left&amp;right都设为0 margin：auto） 水平垂直居中小结- 一般情况下，用绝对定位加负边距，缺点是需要知道宽高，使用transform倒是可以不需要，但是兼容性不好（ie9+） - 其次就是绝对居中，让浏览器自动平分边距以达到水平垂直居中的目的 - 如果是行内/行内块级/图片这些，可以优先考虑line-height和vertical-align结合使用，不要忘了还有text-align - 移动端兼容性允许的话能用flex就用flex 两列布局 (1) 左列定宽，右列自适应1.1 利用float+margin实现html: 1234&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#left&#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right&#123; background-color: #0f0; height: 500px; margin-left:100px &#125; //注意:margin-left要大于等于#left的宽度 1.2 利用float+margin(fix)实现html: 123456&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right-fix&quot;&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415#left&#123; bacground-color: #f00; float: left; width: 100px; height: 500px;&#125; #right-fix&#123; float: right; width: 100%; margin-left: -100px; &#x2F;&#x2F;正值大于或等于#left的宽度，才能显示在同一行&#125; #right&#123;margin-left: 100px; &#x2F;&#x2F;大于或等于#left的宽度background-color: #0f0;height: 500px;&#125; 1.3 使用float+overflow实现html: 1234&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011 #left&#123; background-color: $f00; float: left;width: 100px;height: 500px; &#125; #right&#123;background-color: #0f0;height: 500px;overflow: hidden; &#x2F;&#x2F;触发bfc达到自适应 &#125; 缺点：浮动脱离文档流，需要手动清除浮动，否则会产生高度塌陷1.4 使用table实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;&quot;right&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415 #parent&#123;width: 100%;display: table;height: 500px; &#125; #left&#123;width: 100px;background-color: #f00; &#125; #right&#123;background-color: #0f0; &#125; #left,#right&#123;display: table-cell; &#125; 1.5 使用绝对定位实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;&quot;right&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819 #parent&#123;position: relative; &#x2F;&#x2F;子绝父相 &#125; #left&#123;position: absolute;top: 0;left: 0;background-color: #f00;width: 100px;height: 500px; &#125; #right&#123;position: absolute;top: 0;left: 100px; &#x2F;&#x2F;值大于等于#left的宽度right: 0;background-color: #0f0;height: 500px; &#125; 1.6 使用flex实现html: 123456 &lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 12345678910111213 #parent&#123;width: 100%;height: 500px;display: flex; &#125; #left&#123;width: 100px;background-color: #f00; &#125; #right&#123;flex: 1; &#x2F;&#x2F;均分父元素剩余空间background-color: #0f0; &#125; 1.7 使用Grid实现html: 123456 &lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112 #parent &#123; width: 100%; height: 500px; display: grid; grid-template-columns: 100px auto; &#x2F;*设定2列就ok了,auto换成1fr也行*&#x2F; &#125; #left &#123;background-color: #f00; &#125; #right &#123;background-color: #0f0; &#125; (2)左列自适应，右列定宽 2.1 使用float+margin实现html: 123456 &lt;body&gt; &lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314151617#parent &#123; height: 500px; padding-left: 100px; &#x2F;&#x2F;抵消#left的margin-left以达到parent水平居中&#125;#left &#123; width: 100%; height: 500px; float: left; margin-left: -100px; &#x2F;&#x2F;正值等于#right的宽度 background-color: #f00;&#125;#right &#123; height: 500px; width: 100px; float; right; background-color: #0f0;&#125; 2.2 使用float+overflowhtml: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&gt; css: 123456789101112#left &#123; overflow: hidden &#x2F;&#x2F;触发bfc height: 500px; background-color: #f00;&#125;#right &#123; margin-left: 10px; &#x2F;&#x2F;margin需要定义在#right中 float: right; width: 100px; height: 500px; background-color: #0f0;&#125; 缺点：浮动脱离文档流，需要手动清除浮动，否则会发生高度塌陷，不支持ie62.3 使用table实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右侧定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; width: 100%; height: 500px; display: table;&#125;#left &#123; background-color: #f00; display: table-cell;&#125;#right &#123; width: 100px; background-color: #f0f0; display: table-cell;&#125; 缺点：margin失效，设置间隔比较麻烦2.4 使用绝对定位实现(子绝父相)html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819#parent &#123; position: relative;&#125;#left &#123; position: absolute; top: 0; left: 0; right: 100px; &#x2F;&#x2F;大于等于right的宽度 background-color: #f00; height: 500px;&#125;#right &#123; position: absolute; top: 0; right: 0; background-color: #0f0; width: 100px; height: 500px;&#125; 2.5 使用flex实现html: 123456&lt;body&gt; &lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112#parent &#123; height: 500px; display: flex;&#125;#left &#123; flex: 1; background-color: #f00;&#125;#right &#123; width: 100px; background-color; #0f0;&#125; 2.6 使用Grid实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#parent &#123; height: 500px; display: grid; grid-template-colums: auto 100px; &#x2F;&#x2F;设定2列，auto换成1fr也行&#125;#left &#123; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125; (3)一列不定，一列自适应(盒子宽度随着内容增加或减少发生变化，另一个盒子自适应) 3.1 使用float+overflow实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#left &#123; margin-right: 10px; float: left; &#x2F;&#x2F;只设置浮动，不设宽度 height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; &#x2F;&#x2F;触发bfc height: 500px; background-color: #0f0;&#125; 3.2 使用flex实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent&#123; display: flex; &#125; #left &#123; &#x2F;*不设宽度*&#x2F; margin-right: 10px; height: 500px; background-color: #f00; &#125; #right &#123; height: 500px; background-color: #0f0; flex: 1; &#x2F;*均分#parent剩余的部分*&#x2F; &#125; 3.3 使用Grid实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; display: grid; grid-template-colums; auto 1fr; &#x2F;&#x2F;auto和1fr换一下顺序就是左列自适应，右列不定宽了&#125;#left &#123; margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0;&#125; 三列布局 1.1 两列定宽，一列自适应 (1)使用float+margin实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718192021#parent&#123; min-width: 310px; &#x2F;&#x2F;100+10+200,防止宽度不够，子元素换行&#125;#left&#123; margin-right: 10px; &#x2F;&#x2F;#left和#center间隔 float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right&#123; margin-left: 320px; &#x2F;&#x2F;等于#left和#center的宽度之和加上间隔 height: 500px; background-color: #0f0;&#125; (2)使用float+overflow实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819202122#parent&#123; min-width: 310px; &#x2F;&#x2F;100+10+200,防止宽度不够，子元素换行 &#125; #left&#123; margin-right: 10px; &#x2F;&#x2F;#left和#center间隔 float: left; width: 100px; height: 500px; background-color: #f00; &#125; #center&#123; margin-right: 10px; &#x2F;&#x2F;在此定义和#right的间隔 float: left; width: 200px; height: 500px; background-color: #eeff2b; &#125; #right&#123; overflow: hidden; &#x2F;&#x2F;触发bfc height: 500px; background-color: #0f0; &#125; (3)使用table实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819202122#parent&#123; width: 100%; height: 520px; &#x2F;&#x2F;抵消上下间距10*2的高度影响 margin: -10px 0; &#x2F;&#x2F;抵消上下边间距10的位置影响 display: table; &#x2F;&#x2F;左右两边间距大了一点，子元素改用paddig设置盒子间间距就没有这个问题 border-spacing: 10px; &#x2F;&#x2F;关键！！ 设置间距&#125;#left&#123; display: table-cell; width: 100px; background-color: #f00;&#125;#center&#123; display: table-cell; width: 200px; background-color: #eeff2b;&#125;#right&#123; display: table-cell; background-color: #0f0;&#125; (4)使用flex实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718#parent&#123; height: 500px; display: flex;&#125;#left&#123; margin-right: 10px; &#x2F;&#x2F;间距 width: 100px; background-color: #f00;&#125;#center&#123; margin-right: 10px; &#x2F;&#x2F;间距 width: 200px; background-color: @eeff2b;&#125;#right&#123; flex: 1; &#x2F;&#x2F;均分parent剩余的部分达到自适应 background-color: #0f0;&#125; (5)使用Grid实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516#parent &#123; height: 500px; display: grid; grid-template-columns: 100px 200px auto; &#x2F;*设置3列,固定第一第二列的宽度,第三列auto或者1fr*&#x2F; &#125; #left &#123; margin-right: 10px; &#x2F;*间距*&#x2F; background-color: #f00; &#125; #center &#123; margin-right: 10px; &#x2F;*间距*&#x2F; background-color: #eeff2b; &#125; #right &#123; background-color: #0f0; &#125; 1.2两侧定宽，中间自适应 (1)双飞翼布局 html: 12345678910111213&lt;body&gt; &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt; &lt;!--中间栏需要放在前面--&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;center&quot;&gt; &lt;div id&#x3D;&quot;center_inbox&quot;&gt;中间自适应&lt;&#x2F;div&gt; &lt;hr&gt; &lt;!--方便观察原理--&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233343536#header &#123; height: 60px; background-color: #ccc; &#125; #left &#123; float: left; width: 100px; height: 500px; margin-left: -100%; &#x2F;*调整#left的位置,值等于自身宽度*&#x2F; background-color: #f00; opacity: 0.5; &#125; #center &#123; height: 500px; float: left; width: 100%; background-color: #eeff2b; &#125; #center_inbox&#123; height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; &#x2F;*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*&#x2F; &#125; #right &#123; float: left; width: 200px; height: 500px; margin-left: -200px; &#x2F;*使right到指定的位置,值等于自身宽度*&#x2F; background-color: #0f0; opacity: 0.5; &#125; #footer &#123; clear: both; &#x2F;*注意清除浮动!!*&#x2F; height: 60px; background-color: #ccc; &#125; (2)圣杯布局 html: 123456789101112&lt;body&gt; &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;!--#center需要放在前面--&gt; &lt;div id&#x3D;&quot;center&quot;&gt;中间自适应 &lt;hr&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 1234567891011121314151617181920212223242526272829303132333435363738394041#header&#123; height: 60px; background-color: #ccc; &#125; #parent &#123; box-sizing: border-box; height: 500px; padding: 0 215px 0 115px; &#x2F;*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*&#x2F; &#125; #left &#123; margin-left: -100%; &#x2F;*使#left上去一行*&#x2F; position: relative; left: -115px; &#x2F;*相对定位调整#left的位置,正值大于或等于自身宽度*&#x2F; float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5; &#125; #center &#123; float: left; width: 100%; &#x2F;*由于#parent的padding,达到自适应的目的*&#x2F; height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b; &#125; #right &#123; position: relative; left: 215px; &#x2F;*相对定位调整#right的位置,大于或等于自身宽度*&#x2F; width: 200px; height: 500px; margin-left: -200px; &#x2F;*使#right上去一行*&#x2F; float: left; background-color: #0f0; opacity: 0.5; &#125; #footer&#123; height: 60px; background-color: #ccc; &#125; (3)使用Grid实现 (4)使用table实现 (5)使用flex实现 (6)使用position 多列布局 等宽布局 1.1四列等宽 (1)使用float实现 html: 12345678&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718#parent &#123; margin-left: -20px; &#x2F;*使整体内容看起来居中,抵消padding-left的影响*&#x2F; &#125; .column&#123; padding-left: 20px; &#x2F;*盒子的边距*&#x2F; width: 25%; float: left; box-sizing: border-box; border: 1px solid #000; background-clip: content-box; &#x2F;*背景色从内容开始绘制,方便观察*&#x2F; height: 500px; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：需要手动清浮动，否则会产生高度塌陷 (2)使用table实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516#parent &#123; height: 540px; &#x2F;*抵消上下边20*2间距的高度影响*&#x2F; display: table; margin: -20px 0; &#x2F;*抵消上下边20*2间距的位置影响*&#x2F; &#x2F;*两边离页面间距较大,改用子元素设置padding来当成间隔就不会有这样的问题*&#x2F; border-spacing: 20px; &#x2F;*设置间距*&#x2F; &#125; .column&#123; display: table-cell; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：margin失效 (3)使用flex实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415#parent &#123; margin-left: -15px; &#x2F;*使内容看起来居中*&#x2F; height: 500px; display: flex; &#125; .column&#123; flex: 1; &#x2F;*一起平分#parent*&#x2F; margin-left: 15px; &#x2F;*设置间距*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 1.2多列等宽 (1)使用float实现 html: 12345678910&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; height: 500px; &#125; .column&#123; float: left; &#x2F;*添加浮动*&#x2F; width: 16.66666666666667%; &#x2F;*100÷列数,得出百分比*&#x2F; height: 500px; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：需手动清浮动，否则会产生高度塌陷 (2)使用table实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; width: 100%; height: 500px; display: table; &#125; .column&#123; display: table-cell; &#x2F;*无需关注列数,单元格自动平分*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：margin失效，设置间隔比较麻烦 (3)使用flex实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; height: 500px; display: flex; &#125; .column&#123; flex: 1; &#x2F;*无需关注列数,一起平分#parent*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; (4)使用Grid实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112#parent &#123; height: 500px; display: grid; grid-template-columns: repeat(6,1fr); &#x2F;*6就是列数*&#x2F;&#125;.column&#123;&#125;.column:nth-child(odd)&#123; background-color: #f00;&#125;.column:nth-child(even)&#123; background-color: #0f0;&#125; 九宫格布局(1)使用table实现html: 12345678910111213141516171819&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: table; &#125; .row &#123; display: table-row; &#125; .item &#123; border: 1px solid #000; display: table-cell; &#125; (2)使用flex实现 html: 12345678910111213141516171819&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;css: 123456789101112131415#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: flex; flex-direction: column; &#125; .row &#123; display: flex; flex: 1; &#125; .item &#123; flex: 1; border: 1px solid #000; &#125; (3)使用Grid实现html: 12345678910111213&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css 1234567891011#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: grid; grid-template-columns: repeat(3, 1fr); &#x2F;*等同于1fr 1fr 1fr,此为重复的合并写法*&#x2F; grid-template-rows: repeat(3, 1fr); &#x2F;*等同于1fr 1fr 1fr,此为重复的合并写法*&#x2F; &#125; .item &#123; border: 1px solid #000; &#125; 栅格系统 全屏布局 (1)绝对定位实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233html, body, #parent &#123;height: 100%;overflow: hidden;&#125;#parent &gt; div &#123; border: 1px solid #000;&#125;#top &#123; position: absolute; top: 0; left: 0; right: 0; height: 100px;&#125;#left &#123; position: absolute; top: 100px; &#x2F;*值大于等于#top的高度*&#x2F; left: 0; bottom: 50px; &#x2F;*值大于等于#bottom的高度*&#x2F; width: 200px;&#125;#right &#123; position: absolute; overflow: auto; left: 200px; &#x2F;*值大于等于#left的宽度*&#x2F; right: 0; top: 100px; &#x2F;*值大于等于#top的高度*&#x2F; bottom: 50px; &#x2F;*值大于等于#bottom的高度*&#x2F;&#125;#bottom &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 50px;&#125; (2)flex html: 12345678910&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;middle&quot;&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;html,body,#parent&#123; height:100%;&#125;#parent &#123; display: flex; flex-direction: column;&#125;#top &#123; height: 100px;&#125;#bottom &#123; height: 50px;&#125;#middle &#123; flex: 1; display: flex;&#125;#left &#123; width: 200px;&#125;#right &#123; flex: 1; overflow: auto;&#125; (3)Grid实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233343536*&#123; margin: 0; padding: 0;&#125;html, body, #parent &#123; height: 100%;&#125;#parent &#123; width: 100%; height: 100%; display: grid; &#x2F;*分成2列,第一列宽度200px,第二列1fr平分剩余的部分,此处换成auto也行*&#x2F; grid-template-columns: 200px 1fr; &#x2F;*分成3行,第一行高度100px,第二行auto为自适应,此处换成1fr也行,第3行高度为50px*&#x2F; grid-template-rows: 100px auto 50px; &#x2F;*定义网格区域分布*&#x2F; grid-template-areas: &quot;header header&quot; &quot;aside main&quot; &quot;footer footer&quot;;&#125;#parent&gt;div&#123; border: 1px solid #000;&#125;#top&#123; grid-area: header; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#left&#123; grid-area: aside; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#right&#123; grid-area: main; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#bottom&#123; grid-area: footer; &#x2F;*指定在哪个网格区域*&#x2F;&#125; 补充 盒子模型:标准（box-sizing:content-box）/怪异(box-sizing:border-box)标准盒: 元素的宽等于 style里的width+margin+border+padding。 width=content（不包括padding和border）怪异盒: 元素的宽 等于style里的width宽度。 width= content+padding+border em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小——MDNem根据父级的font-size变化 rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDNrem根据根的font-size变化 行内元素和块级元素行内元素（display：inline）：宽度和高度由内容决定块级元素（display：block）：默认宽度由父元素决定（平时经常使用display：inline-block 使它拥有更多的状态） 绝对定位和相对定位position:absolute 相对于元素最近的已定位的祖先元素position:relative 相对定位是相对于元素在文档中的初始位置 flex布局Flex布局元素，称为Flex容器，简称”容器”。它的所有子元素自动成为容器元素，简称”项目”(1)flex-direction:决定主轴的方向（即项目的排列方式） display: flex; flex-direction: row; (主轴水平方向，起点在左侧) flex-direction: row-reverse(起点在右侧)flex-direction: column(主轴垂直方向，起点在上沿) flex-direction: column-reverse(主轴在垂直方向，起点在下沿)(2)flex-wrap: 默认情况下，项目都排在一条线上（轴线上） flex-wrap: wrap(换行，第一行在上面) flex-wrap: wrap-reverse;(换行，第一行在下面)(3)flex-flow: flex-direction和flex-wrap的简写，默认为row,nowrap(4)justify-content: 定义了项目在主轴上的对齐方式 justify-content： flex-start （默认:左对齐）flex-end (右对齐) center(居中) space-between(两端对齐，项目之间的间隔相等) space-around(每个项目两侧的间距相等)(5)align-items: 定义项目交叉轴上如何对齐(垂直方向) flex-start (交叉轴起点对齐) flex-end (交叉轴终点对齐) center(垂直方向，中间开始) baseline(项目第一行文字的基线对齐) stretch （默认值，如果项目未设置高度或设为auto,将占满整个容器的高度)(6)align-content: 多行轴线对齐 (用法同align-items)(7)flex项目属性 1.order 定义项目排列顺序 order：number(数值越小越靠前，默认为0) 2.flex-grow 定义项目放大比例 flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推） 3.flex-shrink 定义项目缩小比例 flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小） 4.flex-basis 定义项目自身大小 flex-basis ：number/auto （默认auto) 5.flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto 6.align-self 项目自身对齐 BFCBFC:格式化上下文，是一个独立的渲染区域，让处于BFC的内部的元素与外部的元素隔离，使内外元素的定位不会相互影响如何产生: display:inline-block/flex/table-cell/inline-flex; position:absolute/fixed作用: 解决上外边距重叠（重叠的两个box都开启bfc）解决浮动引起的高度塌陷（容器盒子开启bfc） 解决文字焕然图片（左边图片div，右边文字容器p开启bfc） 水平居中和垂直居中 水平居中：行内：display: inline-block块级：margin: 0 auto; (要设宽度) flex：display: flex; justify-content: center;(在主轴上的对齐方式) 垂直居中：行高=元素高：line-height: height;flex: dispkay: flex; align-items: center; JS 几条基本规范 不要在同一行声明多个变量 请使用===/！==来比较true/false或者数值 使用对象字面量替代new Array这种形式 引用方法 行内引入（不推荐） 内部引入 外部引入 基本数据类型 Undefined,Null,Boolean,Number,String,新增:Symbol 数组操作 map: 遍历数组，对元素重新组装，生成新数组 forEach: 遍历所有元素 filter: 过滤符合条件的元素 //返回数组 some: 判断是否有至少一个元素符合条件（一个满足即可） every: 判断所有元素是否都符合条件 sort: 排序 slice(start, end): 返回截断后的新数组，不改变原数组 splice(start, number, value…): 返回删除元素组成的数组，value 为插入项，改变原数组 内置对象 Object是JS中所有对象的父对象 数据封装对象: Object,Array,Boolean,Number和String 其他对象: Function,Arguments,Math,Date,RegExp,Error get和post请求在缓存方面的区别 get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 闭包(closure) 一个作用域可以访问另外一个函数内部的局部变量 闭包的作用: 延伸变量的作用范围，使变量始终保持在内存中（好处: 能够实现封装和缓存） 坏处: 消耗内存，不正当使用会造成内存溢出的问题（在退出函数之前，将不使用的局部变量全部删除） 闭包经典问题题目1: 12345for(var i &#x3D; 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); &#125; //3个3。 for循环是同步，先执行三遍for，i变成了3，然后再执行异步代码setTimeout，这时候输出i，3个3 12345for(let i &#x3D; 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; //0,1,2 在这里，每个let和代码块结合起来形成块级作用域，当setTimeout打印时，会寻找最近的块级作用域中的i，依次打印出0 1 2 题目2: 12345678910var name &#x3D; &quot;This window&quot;var object &#x3D; &#123; name: &quot;My object&quot; getNameFunc: function()&#123; return function()&#123; return this.name &#125; &#125; &#125;console.log(object.getNameFunc()()) 解释:类似于: 123456789var f &#x3D; object.getNameFunc()var f &#x3D; function()&#123; return this.name &#125;求f()funtion()&#123; return this.name&#125;() &#x2F;&#x2F; 输出“This window” 立即执行函数中的this指向window 题目3: 1234567891011 var name &#x3D; &quot;This window&quot; var object &#x3D; &#123; name: &quot;My object&quot; getNameFunc: function()&#123;var that &#x3D; this return function()&#123; return that.name &#125; &#125; &#125; console.log(object.getNameFunc()()) 解释: 类似于: 123456789var f &#x3D; object.getNameFunc() var f &#x3D; function()&#123; return that.name &#125;求f() funtion()&#123; return that.name&#125;() &#x2F;&#x2F; 输出“My object” 作用域 全局作用域/函数作用域 原型 原型规则(1)对象，数组，函数，都可以自由扩展属性(2)对象，数组，函数，都有一个proto属性(3)所有函数都有一个prototype属性(4)obj.proto === Object.prototype(5)当试图得到一个对象的属性时，如果这个对象本身没有这个属性，那么就会去它的proto（即它的构造函数的prototype）中寻找 如何准确判断一个变量是数组类型？instanceofinstanceof的原理就是利用了原型链，当执行arr instanceof Array时，会从arr的proto一层一层往上找，看是否能查到Array的prototype 写出一个原型链继承的例子（封装“数据和算法”的例子） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;封装二叉搜索树function BinarySearchTree()&#123; &#x2F;&#x2F;内部类，节点 function Node(key)&#123; this.key &#x3D; key this.left &#x3D; null this.right &#x3D; null &#125;&#x2F;&#x2F;属性this.root &#x3D; null&#x2F;&#x2F;方法 &#x2F;&#x2F;插入数据:对外给用户调用的方法BinarySearchTree.prototype.insert &#x3D; function(key)&#123; &#x2F;&#x2F;根据key创建节点 var newNode &#x3D; new Node(key) &#x2F;&#x2F;判断根节点是否有值 if(this.root &#x3D;&#x3D; null)&#123; this.root &#x3D; newNode &#125; else &#123; this.insertNode(this.root, newNode) &#125;&#125;BinarySearchTree.prototype.insertNode &#x3D; function(node, newNode)&#123; if(newNode.key &lt; node.key)&#123; &#x2F;&#x2F;向左查找 if(node.left &#x3D;&#x3D; null)&#123; node.left &#x3D; newNode &#125;else &#123; this.insertNode(node.left, newNode) &#125; &#125; else &#123; &#x2F;&#x2F;向右查找 if(node.right &#x3D;&#x3D; null)&#123; node.right &#x3D; newNode &#125;else &#123; this.insertNode(node.right, newNode) &#125; &#125;&#125;&#125;&#x2F;&#x2F;测试var bst &#x3D; new BinarySearchTree()bst.insert(11)bst.insert(7)bst.insert(15)bst.insert(5&#125;console.log(bst) 描述new一个对象的过程 1.创建一个对象 2.获得构造函数的prototype属性，并把prototype赋值给新对象的proto，this指向这个新对象 3.执行构造函数。返回构造函数的内容 组件化开发/模块化开发 组件化开发 –&gt;功能拆分，组件封装，以达到组件复用性，增强代码可读性，提高维护性 模块化开发 –&gt;避免变量污染（不用全局变量，不会带来污染/覆盖），命名冲突， 提高代码复用率，提高可维护性， 方便依赖关系管理(export暴露出去，引用谁，再执行，依赖关系明确) –&gt;AMD (异步模块规范) 先define(…)才能require(…) –&gt;CommonJS (nodejs模块化规范) 要先配置webpack （webpack的配置：context,entry,output,（构建工具：grunt,gulp,fis,webpack））CommonJS不会异步加载JS，而是一次性加载进来 –&gt;使用场景 需要异步加载JS，使用AMD使用了npm，建议使用CommonJS 异步和单线程 JS是单线程的语言，如果要同时处理多件事，要用异步 –&gt;异步：所有的“等待的情况”都需要异步（定时任务：setTimeout setInterval。 网络请求：ajax请求，动态加载。 事件绑定（可以当作异步来理解）） –&gt;同步和异步的区别？ 阻塞。 alert（同步） setTimeout（异步） Ajax (XMLHttpRequest，状态码说明，跨域) 手写一个ajax请求 12345678910 var xhr &#x3D; new XMLHttpRequest() xhr.open(&#39;GET&#39;,&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;first&#39;) xhr.onreadystatuschange &#x3D; function()&#123; if (xhr.readystatus &#x3D;&#x3D; 4)&#123; if(xhr.status &#x3D;&#x3D; 200)&#123; alert(xhr.responseText) &#125;&#125; &#125; xhr.send(null) 状态码xhr.readystatus: 0(还没发送send请求),1（正在发送请求）,2（send（）方法执行完成，已接收全部内容）,3（正在解析响应内容）,4（完成，响应内容解析完成，可以在客户端调用）xhr.status: 2xx 成功处理请求 3xx 需要重定向 4xx 客户端请求错误（如404） 5xx 服务器端错误 ajax（同源政策）ajax只能向自己的服务器发送请求（同源：协议，域名，端口都相同）此时，有跨域的需求 —&gt;跨域？ —&gt;有三个标签允许跨域加载资源, , ---->而script可以使用JSONP方式跨域（json with padding） 1.将不同源的服务器端的地址写在script标签里的src里 2.服务器端响应数据必须是一个函数的调用，要发送给客户端的数据需要作为函数调用的参数 3.客户端全局作用域下定义函数fn 4.在fn函数内部对服务器端返回的数据进行处理 ---->跨域方法2: CORS 跨域资源共享 服务器端操作 设置http header ----->跨域方法3: 两台服务器之间操作 存储 请描述一下cookie，sessionStorage和localStorage的区别 1.容量。cookie不能超4k 。 sessionStorage和localStorage可以达到5M或更大 2.所有的http请求都携带cookie 3.数据有效期不同，sessionStorage在会话结束时（浏览器关闭时），会自动清理。cookie在设置的过期时间之前都有效。localStorage始终有效 ----> cookie 客户端第一次请求服务器，服务端响应cookie 第二次：客户端携带cookie请求服务器 图片的预加载和懒加载 预加载: 提前加载图片，当用户需要查看时可直接从本地缓存中渲染 懒加载: 作为服务器前端的优化，减少请求次数或延迟请求数 预加载增加服务器前端压力，懒加载对服务器有一定的缓解压力作用 mouseover和mouseenter的区别 不论鼠标指针穿过被选元素或其子元素，都会触发mouseover事件。对应mouseout（冒泡） 只有在鼠标指针穿过被选元素时，才会触发mouseenter事件。对应mouseleave 解决异步回调地狱 promise(key word: resolve,reject,then)、generator、async/await（将异步代码写成同步的形式） await 暂停当前整个异步函数向下执行，直到promise返回结果（这里的promise指的是await后面的promise对象，await后面只能写promise对象） 对this的理解 this总是指向函数的直接调用者 如果有new关键字，this指向new出来的那个对象 改变this指向 --->箭头函数: 箭头函数的this始终指向函数定义时的this，而非执行时 --->在函数内部使用_this = this --->apply,call,bind apply和call: 调用函数，改变this指向，传入参数不同，call接受的是若干个参数列表，apply接收的是一个包含多个参数的数组。 bind: 不会调用函数，改变this指向 React 其他 项目经验","categories":[],"tags":[]},{"title":"NEXTJS PROJECT项目学习","slug":"NEXTJS-PROJECT项目学习","date":"2020-06-05T09:04:36.000Z","updated":"2020-06-09T05:49:21.325Z","comments":true,"path":"2020/06/05/NEXTJS-PROJECT项目学习/","link":"","permalink":"http://yoursite.com/2020/06/05/NEXTJS-PROJECT%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"React学习","slug":"React学习01","date":"2020-06-03T05:51:40.000Z","updated":"2020-06-15T06:48:42.646Z","comments":true,"path":"2020/06/03/React学习01/","link":"","permalink":"http://yoursite.com/2020/06/03/React%E5%AD%A6%E4%B9%A001/","excerpt":"","text":"JSX语法 写在{}里的html语法 组件 组件的类型1.函数类型的组件(hooks之后都可以用这种方式吧)name()&#123;return hello world&#125;```12 2.基于类的组件&#96;&#96;&#96; class xxx extends React.Component&#123;render()&#123;return &lt;div&gt;hello world&lt;&#x2F;div&gt;&#125;&#125; state 和 setState 条件渲染和循环 事件监听 组件通信 生命周期 redux 一个专门用于做状态管理的JS库（不是react插件库）。与react最适配。管理react应用中多个组件共享的状态 action creator&lt;—— component &lt;—–&gt; store &lt;——&gt; reducer action{type: ,data: ,} reducer(state=0,action) react-redux 一个react插件库，专门用来简化react应用中使用redux 思想：(component) UI组件 里不使用redux的api + 容器组件（container)里使用redux的api Provider:让所有组件都可以得到state数据 接收一个store connect连接store:用于包装UI组件生成容器组件 把state to props，dispatch to props ,传给容器组件 redux异步编程（异步中间件） redux默认是不能进行异步处理的，应用中又需要在redux中执行异步任务，则需要redux异步中间件 actions.js里，返回一个函数（同步的时候返回的是对象） axios 封装 XmlHttpRequest 对象的ajax。promise风格。可以用在浏览器端和node服务器端 react-router react的一个插件库,专门用来实现一个SPA应用（single page web application，单页web应用） SPA应用:整个应用只有一个完整的页面,点击页面中的链接不会刷新页面，本身也不会向服务器发送请求，当点击路由链接时，只会做页面局部的更新,数据都需要通过ajax请求获取 route 路由，一个路由就是一个映射关系，key为路由路径，value可能是function/component（后台路由：value是function，前台路由：value是component） （注册路由：router.get(path,function(req,res))） 前端路由的实现1）histtory库:包装的是原生BOM中window.history和window.location.hash 1.BrowserRouter 2. (a标签的改写) 3. (有两个的话外围再用switch包一下) 4. (默认显示)","categories":[],"tags":[]},{"title":"网站demo (jQuery)","slug":"我的第一篇博客文章","date":"2020-06-02T02:40:43.000Z","updated":"2020-06-03T04:36:25.095Z","comments":true,"path":"2020/06/02/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/06/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"功能模块 登陆功能 为登陆按钮添加点击事件 获取用户在文本框中输入的用户名和密码 验证用户是否输入了用户名和密码，没有则阻止程序向下执行 调用实现登陆功能的接口（ajax），登陆成功，跳转到下一页 登陆拦截 使用script标签加载服务器端提供的接口地址（不用ajax，因为ajax是异步的不会阻止程序向下执行），且还需在最上方 判断isLogin变量， 如果为false，跳转登陆页面 退出功能 为退出按钮添加点击事件 利用confirm方法返回值（当用户点击确定–&gt;true,点击取消—-&gt;false） 当true时调用$.ajax方法(不用传递参数) 添加用户 1.在表单中，为添加的用户的每一项添加name属性，（name属性要和接口文档中要求的参数名称保持一致） 2.为表单绑定提交事件，（在事件处理函数中要阻止表单默认提交的行为） 3.在事件处理函数中获取用户在表单中输入的内容（ serialize()方法: 将内容格式化成参数字符串 ） var formData = $(this).serialize() (formData传到ajax里的data中) 4.调用添加用户的接口，将获取到的内容通过接口发送给服务端，操作成功—&gt;刷新页面，失败–&gt;用户提示 用户头像上传 1.为文件选择控件添加onchange事件，在事件处理函数中获取到用户选择的文件 2.创建formData对象用于实现图片文件上传 (用户选择到的文件为 this.files[0] ) formData 1formData.append(&#39;avatar&#39;,this.files[0]) （将用户的文件上传给服务器端） 3.调用图片文件上传接口($.ajax中设置processData: false //告诉$.ajax不要解析请求参数。因为当前时二进制文件上传，所以不用解析。设置contentType: false //告诉$.ajax方法不要设置请求参数的类型) 4.在添加新用户表单中新增一个隐藏域，将图片地址存储在隐藏域中 &lt;input type=&quot;hidden&quot; name=&quot;avatar&quot; id=&quot;hiddenAvatar&quot;&gt; (name值要跟文档匹配) 5.（服务器返回的是上传的文件的地址）。 在success函数中两件事：1.头像预览$(&#39;#preview&#39;).attr(&#39;src&#39;, response[0].avatar) 2.将图片地址存在隐藏域中$(&#39;#hiddenAvatar&#39;).val(response[0].avatar) (提交给服务器端用) 用户列表展示 (10132967) 1.在页面加载时向服务器发送ajax请求，索要用户列表数据 2.使用模版引擎将数据和html模版拼接 3.将拼接好的内容展现在页面中 用户信息修改 一、通过事件委托的形式为编辑按钮添加点击事件（用户信息修改功能，要把用户信息展示在页面上，因为用ajax向服务器请求的数据不知什么时候返回，所以用事件委托的方式，为他的父级添加点击事件） 在事件处理函数中获取当前点击的用户的ID值 根据用户ID获取用户的详细信息（$.ajax),并通过模版引擎将用户信息渲染在表&gt;单中 二、为提交按钮添加点击事件。（也要用事件委托的形式）1.获取用户在表单中&gt;输入的内容，2.调用修改用户信息接口实现用户信息修改功能（$.ajax）,success函数里location.reload(),刷新页面(下面的意思是当点击’edit’类的时候，触发冒泡机制，触发userBox的点击事件的处理函数)$(&#39;#userBox&#39;).on(&#39;click&#39;, &#39;.edit&#39;, function () {} 删除用户 为删除按钮添加点击事件（事件委托的方法） 确认用户是否要进行删除（confirm方法） 获取当前被点击的用户的ID 调用删除用户接口根据ID删除用户，成功—&gt;刷新页面 第二章","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}