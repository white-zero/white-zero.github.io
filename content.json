{"meta":{"title":"Hexo","subtitle":"","description":"","author":"White Zero","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"UniApp","slug":"UniApp","date":"2020-06-28T11:21:24.000Z","updated":"2020-07-05T06:11:12.026Z","comments":true,"path":"2020/06/28/UniApp/","link":"","permalink":"http://yoursite.com/2020/06/28/UniApp/","excerpt":"","text":"UniApp 同一套代码编译多端 接近原生，效果更好 开发效率高，成本降低，学习成本低 支持npm与自定义组件 社区活跃，版本迭代快 框架基础 MVC与MVVM思想 MVC：后端思想view&lt;—&gt;Controller&lt;—&gt;Model –&gt;M：model-模型层，数据的增删改查 –&gt;V：view-视图层，前端页面（html/js/css） –&gt;C：controller-控制层，处理业务 MVVM： View( 页面HTML)&lt;—&gt;ViewModel（核心调度者协调器在script里，数据双向绑定）&lt;—&gt;Model（单页面的静态数据，在script的data里） 应用生命周期 onLaunch（当uni-app初始化完成时触发，全局只触发一次） onShow（启动，或从后台进入前台显示时） onHide（从前台进入后台时） onUniNViewMessage 页面生命周期 onLoad 监听页面加载 onUnload 监听页面卸载 onShow 监听页面显示 onHide 监听页面隐藏 onReady 监听页面初次渲染完成 数据绑定 在标签外部时，使用： ，当在标签内部时，用v-bind：/： 动态数据绑定时，比如src 要在前面加： 事件处理 条件渲染（全支持vue） 和列表循环（v-for） v-if和v-show的区别：前者 ：是否会在dom中被移除，后者display：none v-for里要 :key=“index” 保证组件和数据捆绑唯一。 –&gt;嵌套循环的时候，:key的内容要不同 ifdef和ifndef （条件编译） ifdef 只在什么地方编译 ifndef 除了不在什么地方编译，在其他地方都编译 可以在html、js、css里写 写在注释里 –&gt;html里 –&gt;js里 //#ifdef MP-WEIXIN //#endif –&gt;style里 /* #ifdef H5 / / #endif */ 只在H5…&lt; !–more–&gt;=========================================框架基础内容完================================ Flex布局（自适应布局） 主轴 和 交叉轴（主轴：元素排列的顺序，水平时主轴也是水平的） class=”container” .container{display: flex} 则 使用了flex布局 flex-direction(元素的排列方向) –&gt;row row-reverse 横向 –&gt;column colunmn-reverse 纵向 flex-wrap 换行 –&gt;nowrap wrap wrap-reverse justify-content 设置元素在主轴上的对齐方式 –&gt;flex-start flex-end –&gt;center –&gt;space-between space-around （元素的中间/两边 留有空格, space-around时旁边和中间的间隙是1:2） align-items (设置元素在交叉轴上的对齐方式) –&gt;flex-start flex-end –&gt;center –&gt;streth(默认：拉伸) 当元素的高度没有设置，则元素的高度会拉伸至容器高度一致 –&gt;baseline（保证元素中的文字在同一条基准线（保证每个文字都在同一条线上）） align-content 设置轴线的对齐方式（轴线当作元素） –&gt;flex-start flex-end –&gt;center stretch –&gt;space-between space-around order flex容器内部的每个元素的排列顺序（默认都为0） 从小到大排 flex-grow 设置元素的放大比例（默认为 0，不放大 flex-shrink 控制元素缩小比例） flex-basis 设置元素固定或自动空间的占比 align-self: 重写容器中元素在交叉轴上的对齐方式(覆盖父级中的align-items) ===========================================Flex布局完==================================== 首页 轮播图部分（uni-app里swiper组件的使用） –&gt; 后台地址的整合 —&gt;方法1:new一个common.js，在里面const一个serverUrl ，再在页面import common from … ，再var serverUrl = common.serverUrl —&gt;方法2:直接在main.js里，把serverUrl挂载到Vue的prototype上，在页面使用时，直接serverUrl = this.serverUrl 评分部分 –&gt; 共用组件的抽取 组件 —&gt;new一个后缀为vue的文件，在template中的name写上组件名字， , script中export default里写上name（和组件名一致),return的data里写上msg：’xxxx’ —&gt;页面的script中import组件 —&gt;onload中，加一个components的属性，写上组件的名字（注册组件 —&gt;template里用标签使用 –&gt; 父子组件传值（往自定义的组件里传参数） —&gt;在index页面（父页面）的自定义组件的标签中，写上myvalue=“xxx” (myvalue是自定义的属性名) —&gt;在自定义组件页面，（子页面）的script中加上props属性，写上myvalue的属性名，并写明type，定义这个参数的类型 —&gt;在自定义组件页面的template里加上例如input的标签，写上:value=“myvalue” —&gt;实现 页面无法下滑问题 –&gt; 取消公共属性里page里写的position的absolute 点赞动画 –&gt;标签里 :animation=”animationData” data里加一个animationData:{} –&gt;onload时 this.animation = uni.createAnimation() –&gt;method 新建一个方法（在template里记得加），动作做完，记得this.animationData = this.animation.export()暴露出去 –&gt;用setTimeout还原动画，onUnload时this.animationData = {} 清除动画数据 —&gt;点赞动画中，指定动作与该行相关联---&gt;data中加一个animationDataArr的空数组（里面写上对应几个空的对象） ---&gt;标签中animation动态绑定animationDataArr[gIndex] ，列表中遍历 v-for = （guess,gIndex）in guessULikeList ---&gt;在点赞动作加一个 :data-gIndex=&quot;gIndex&quot; ---&gt;在点击动作的method中，var gIndex = e.currentIndex.dataset.gindex (dataset里所有的值都是小写) ---&gt;this.animationData = this.animation ---&gt;this.animationDataArr[gIndex] = this.animationData.export() ---&gt;页面卸载onUnload时，要把this.animationDataArr:[{},{},{},......] 再设回空 下拉加载刷新 –&gt;pages.json里加enablePullDownRefresh true –&gt;request的方法中有complete方法，在里面使用uni.stopPullDownRefresh() –&gt;“交互效果” 页面中央的loading：在refresh里uni.showLoading（{mask: true}） (mask蒙版，刷新时用户无法点击后面的内容) –&gt;在complete中，uni.hideLoading() —&gt;方法2:导航条加载动画---&gt;uni.showNavigationBarLoading 并且，去掉pages.json里的titleNView：false改为true （取消禁用原生导航栏） ---&gt;在complete中，uni.hideNavigationBarLoading() 搜索页 下拉时固定搜索栏 –&gt;position: fixed; top: 100; z-index: 2000; confirm-type=”search” 小程序输入法右下角变成搜索","categories":[],"tags":[]},{"title":"git push错误non-fastforward","slug":"git push错误non-fastforward","date":"2020-06-19T03:06:33.104Z","updated":"2020-06-19T03:06:33.104Z","comments":true,"path":"2020/06/19/git push错误non-fastforward/","link":"","permalink":"http://yoursite.com/2020/06/19/git%20push%E9%94%99%E8%AF%AFnon-fastforward/","excerpt":"","text":"问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式： 1，强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 git push -f 2，先把git的东西fetch到你本地然后merge后再push $ git fetch $ git merge 这2句命令等价于 $ git pull","categories":[],"tags":[]},{"title":"git的使用","slug":"git的使用","date":"2020-06-16T09:15:46.000Z","updated":"2020-06-22T08:35:29.031Z","comments":true,"path":"2020/06/16/git的使用/","link":"","permalink":"http://yoursite.com/2020/06/16/git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载安装git vim ~/.gitconfig name email alias(命令的缩写) co=checkout(切换分支) ci=commit st=status pl=pull ps=push dt=difftool(提交代码前对比代码) ca=commit -am(备注信息) b=branch 项目的建立(ssh公钥) ssh-keygen -t rsa -C ‘邮箱地址‘ 一路回车 ls -al (显示所有文件，包括git的隐藏文件) cd .ssh/ ls -al id_rsa:私钥 id_rsa.pub:公钥 cat id_rsa.pub 码云 组织—&gt;新建仓库—&gt;管理—&gt;公钥管理—&gt;添加个人公钥 仓库里复制SSH（不用每次输入账号密码） 回到命令行 cd ls(查看当前文件夹) mkdir doc(新建文件夹)。cd进去 git clone (仓库里的ssh复制接到clone后面) yes cd 到对应的仓库里，可以查看文件 在仓库下， vim .gitignore (忽略一些文件) insert .DS_Store(mac下存储文件夹信息的) node_modules dist *.log(日志，不需要) git st 查看状态 git add . (提交到本地) git ca “备注信息“ (用于代码提交到本地) git push (推送到远程) git在远程和在本地的仓库都新建完成 git 更新 git st 查看状态 git pull git merge “ “(没有引号，里面填分支名称，比如 origin) master —&gt; 例如：git merge origin master git add . git ca “备注” git push git tag tag-order (打标签： 标签名为tag-order) git push origin tag-order (给远程的origin的分支打上tag-order的标签)","categories":[],"tags":[]},{"title":"后台管理系统","slug":"后台管理系统","date":"2020-06-16T03:43:01.000Z","updated":"2020-06-22T08:30:47.506Z","comments":true,"path":"2020/06/16/后台管理系统/","link":"","permalink":"http://yoursite.com/2020/06/16/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"https://webthemez.com/demo/insight-free-bootstrap-html5-admin-template/ui-elements.html# (bootstrap免费皮肤) navtop和sidetop 在上面网站中，”Dashboard”—&gt;查看源码—&gt;对应的区域edit as html—&gt;ctrl+c ctrl+v到指定组件中—&gt;修改nav标签为div—&gt;把style去掉—&gt;在网页中，把wrapper中element.style{height: 1000px} 页面不报错，路由跳转出错（考虑route的exact问题） 后台接口 react不向前兼容版本，当找到的插件是依赖于react之前的版本时（在node_modules里面看对应插件的源码，package.json看依赖），会出错 关于react-fileupload的解决方案：1、复制fileupload.js的源码到项目里新建的react-fileupload.jsx中，重新引用 2、npm下载 prop-types(从react文档里得知react在15.5之后就需要下载prop-types使用） 3、在react-fileupload.jsx中，修改为class extend…..的格式，（这一步要去掉括号），加一个constructor this.state里的初始属性从getInnitial里拿，拿完把getInnitial删掉， 把类型验证剪切到新的格式中，import PT from ‘prop-types’ 4、去掉错误的逗号 5、把onClick onChange onSubmit的方法都修改成箭头函数的形式(报beforeChoose的错误，这是因为作用域的问题)","text":"https://webthemez.com/demo/insight-free-bootstrap-html5-admin-template/ui-elements.html# (bootstrap免费皮肤) navtop和sidetop 在上面网站中，”Dashboard”—&gt;查看源码—&gt;对应的区域edit as html—&gt;ctrl+c ctrl+v到指定组件中—&gt;修改nav标签为div—&gt;把style去掉—&gt;在网页中，把wrapper中element.style{height: 1000px} 页面不报错，路由跳转出错（考虑route的exact问题） 后台接口 react不向前兼容版本，当找到的插件是依赖于react之前的版本时（在node_modules里面看对应插件的源码，package.json看依赖），会出错 关于react-fileupload的解决方案：1、复制fileupload.js的源码到项目里新建的react-fileupload.jsx中，重新引用 2、npm下载 prop-types(从react文档里得知react在15.5之后就需要下载prop-types使用） 3、在react-fileupload.jsx中，修改为class extend…..的格式，（这一步要去掉括号），加一个constructor this.state里的初始属性从getInnitial里拿，拿完把getInnitial删掉， 把类型验证剪切到新的格式中，import PT from ‘prop-types’ 4、去掉错误的逗号 5、把onClick onChange onSubmit的方法都修改成箭头函数的形式(报beforeChoose的错误，这是因为作用域的问题) 把jquery组件封装成react组件 解决富文本的问题。（simditor@2.3.6） 登陆页 用户登陆---&gt; 页面：表单格式（bootstrap） —&gt;表单数据的输入，验证，提交 ---&gt;输入框逻辑的封装 –&gt; tip:(外围不用form包，用div) –&gt; ajax请求封装在util(存放通用组件，工具)文件夹下（用promise包） –&gt; 请求的data，type，url 封装在service/user-service里 登陆完成跳转回上一页 登陆状态管理 显示登陆状态 –&gt;用户信息本地存储—头部导航栏的登录信息的显示(localStorage) 退出登陆 首页 数据统计展示 商品 商品管理 –&gt;商品列表的开发(用户列表的复用) —&gt;商品列表 按条件查询 分页---&gt;1.抽取通用的TableList组件，使用Tablist组件重构用户列表 ---&gt;2.搜索功能的开发 –&gt;添加商品 —&gt;表单提交 图片上传 富文本编辑器---&gt;添加商品表单的开发 ---&gt;品类选择器组件，二级联动 ---&gt;文件上传组件，处理React版本兼容问题（react-fileupload@2.4.0） ---&gt;富文本编辑器，结合jquery插件的用法 –&gt;编辑商品 —&gt;表单的回填 —&gt;品类选择器的回填（使用生命周期函数） —&gt;富文本编辑器的回填 –&gt;商品详情页 —&gt;商品详情展示---&gt;品类选择器支持readOnly ---&gt;富文本字段的渲染方式（当作html渲染，dangerouslySetInnerHTML） 品类管理 –&gt;品类列表的开发 —&gt;子品类路由的处理 —&gt;修改品类名称 –&gt;添加品类页面的开发 —&gt;渲染品类信息 —&gt;添加品类 订单 订单管理 –订单列表页（按订单号搜索） –订单详情页（详情信息，发货操作） 用户 用户管理 –&gt; 用户列表(展示用户数据的table的制作 时间戳的处理—&gt;可读的时间格式) –&gt; 分页功能的封装(分页功能用：rc-pagination (当效果没显示时，去node_modules里找对应的css引入)做项目中的封装，使其变为项目中的组件，减少引用它的成本) 错误提示页 错误提示 引导回到首页","categories":[],"tags":[]},{"title":"webpack3.10.0打包配置","slug":"webpack3-10-0打包配置","date":"2020-06-15T06:49:37.000Z","updated":"2020-06-15T10:31:26.655Z","comments":true,"path":"2020/06/15/webpack3-10-0打包配置/","link":"","permalink":"http://yoursite.com/2020/06/15/webpack3-10-0%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"&quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;css-loader&quot;: &quot;^0.28.8&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.2&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;react&quot;: &quot;^16.2.0&quot;, &quot;react-dom&quot;: &quot;^16.2.0&quot;, &quot;react-scripts&quot;: &quot;3.4.1&quot;, &quot;style-loader&quot;: &quot;^0.19.1&quot;, &quot;webpack&quot;: &quot;^3.10.0&quot; &quot;sass-loader&quot;: &quot;^6.0.6&quot;, &quot;node-sass&quot;: &quot;^4.14.1&quot; “font-awesome&quot;: &quot;^4.7.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.7&quot;, 根目录new一个webpack.config.js js 文件打包(react语法的处理) 12345entry: &#39;.&#x2F;src&#x2F;app.jsx&#39;,output: &#123; path: path.resolve(__dirname, &#39;dist&#39;), filename: &quot;app.js&quot;&#125;, html 文件打包 const HtmlWebpackPlugin = require(‘html-webpack-plugin’) 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;)] //temlate是模版。即待打包的html文件 css 文件打包 tips: 要在js文件里import 123456&#123; test: &#x2F;\\.css$&#x2F;, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] - const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) （这个插件可以在打包的文件中，把css独立出来，可以提前加载）代码改为 1234567&#123;test: &#x2F;\\.css$&#x2F;,use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;)&#125; 123456plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;), new ExtractTextPlugin(&quot;index.css&quot;)] sass文件的处理 (一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。) 要同时下载 “sass-loader”: “^6.0.6”,&quot;node-sass&quot;: &quot;^4.14.1&quot; 1234567&#123; test: &#x2F;\\.scss$&#x2F;, use: ExtractTextPlugin.extract(&#123; fallback: &#39;style-loader&#39;, use: [&#39;css-loader&#39;, &#39;sass-loader&#39;] &#125;)&#125;, 图片的打包 下载 url-loader@0.6.2 file-loader@1.1.6 1234567891011&#123;test: &#x2F;\\.(png|jpg|gif)$&#x2F;,use: [ &#123; loader: &quot;url-loader&quot;, options: &#123; limit: 8192 &#125; &#125; ]&#125; 字体图标的配置（npm install font-awesome） 现在js文件中引入 font-awesome/css/font-awesome.min.css 再在webpack.config.js里配置 1234567891011&#123; test: &#x2F;\\.(eot|svg|ttf|woff|woff2|otf)$&#x2F;, use: [ &#123; loader: &#39;url-loader&#39;, options: &#123; limit: 8192 &#125; &#125; ]&#125; 提出公共模块 先 const webpack = require(‘webpack’) 12345678910plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39; &#125;), new ExtractTextPlugin(&quot;css&#x2F;[name].css&quot;), new webpack.optimize.CommonsChunkPlugin(&#123; name : &#39;common&#39;, filename: &#39;js&#x2F;base.js&#39; &#125;)] webpack-dev-server(页面自动更新，挂载在自定义的端口上) 修改端口 123devServer: &#123; port: 8086,&#125; 在output里加publicPath：“/dist/” (当报错一些字体文件找不到的时候加。) 终端 node_modules/.bin/webpack-dev-server 启动 在package.json里加几个scripts 里的字段 12&quot;dev&quot;: &quot;node_modules&#x2F;.bin&#x2F;webpack-dev-server&quot;,&quot;dist&quot;: &quot;node_modules&#x2F;.bin&#x2F;webpack -p&quot; &#x2F;&#x2F;线上环境时，最好后面加上-p","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-12T07:52:12.741Z","updated":"2020-06-12T07:52:12.741Z","comments":true,"path":"2020/06/12/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"面试","slug":"面试","date":"2020-06-09T05:33:48.000Z","updated":"2020-07-03T03:19:15.963Z","comments":true,"path":"2020/06/09/面试/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95/","excerpt":"HTML HTML语义化 如&lt;Header&gt;代表头部，&lt;nav&gt;代表超链接区域，&lt;main&gt;定义文档主要内容，&lt;article&gt;表示文章博客等，&lt;aside&gt;侧边栏，&lt;footer&gt;底部 就是让页面内容结构化。优点如下 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构 有利于SEO（搜索引擎优化，让更多的用户通过搜索引擎搜到你的网站，让更多人喜欢你的网站），搜索引擎根据标签来确定上下文和各个关键字的权重 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，可读性强 HTML5新标签 &lt;header&gt; &lt;footer&gt; &lt;aside&gt; &lt;nav&gt; &lt;video&gt; &lt;audio&gt; &lt;canvas&gt;等…","text":"HTML HTML语义化 如&lt;Header&gt;代表头部，&lt;nav&gt;代表超链接区域，&lt;main&gt;定义文档主要内容，&lt;article&gt;表示文章博客等，&lt;aside&gt;侧边栏，&lt;footer&gt;底部 就是让页面内容结构化。优点如下 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构 有利于SEO（搜索引擎优化，让更多的用户通过搜索引擎搜到你的网站，让更多人喜欢你的网站），搜索引擎根据标签来确定上下文和各个关键字的权重 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，可读性强 HTML5新标签 &lt;header&gt; &lt;footer&gt; &lt;aside&gt; &lt;nav&gt; &lt;video&gt; &lt;audio&gt; &lt;canvas&gt;等… CSSCSS布局 水平居中 text-align:center对于（文本/行内元素/行内块级元素）相对他的块父级元素对齐。优：简单快捷易理解，兼容性好。缺：只对行内内容有效，属性会继承影响到后代行内的内容，如果子元素宽度大于父元素宽度，则无效。只有于才行 width: 100px; margin: 0 auto; 对于单个块级元素优：简单；兼容性好缺：必须定宽度，且值不能为auto，宽度必须小于父元素 #parent{text-align:center;} .son{display: inline-block; } 多个块级元素，相对他的块父元素对齐 使用绝对定位实现（子绝父相）#parent{height:200px; width:200px; position: relative; }#son{position:absolute; left: 50%; } //top 、right 、bottom、 left的值是相对于父元素尺寸的，margin或transform是相对自身 尺寸的，组合使用达到水平居中的目的 flex(任意个元素)#parent{display: flex; justify-content: center; } 设置当前主轴对齐方式为居中。缺：PC端兼容性问题，移动端（Android4.0+） 水平居中小结- 首先想到`text-align:center`,但其只对行内有效。所以使用时将子元素设为`display: inline` 或 `display: inline-block` - 其次考虑用`margin: 0 auto` 但要记得带上宽度。因为这两种代码量少，再次使用绝对定位去实现。 - 移动端能用flex 垂直居中 #parent{height:100px; line-height:100px;} line-height和height等值。对于单行文本/行内元素/行内块级元素优：简单兼容性好缺：只能用于单行行内内容，且要知道高度的值 多行文本/行内元素/行内块级元素#parent{height: 150px; line-height: 30px; } //元素在页面呈现5行，则line-height的值为height/5优点：简单，兼容性好缺点：只能用于行内内容，需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 图片 （vertical-align和line-height）#parent{height:150px; line-height: 150px; font-size:0 } img#son{vertical-align: middle } //默认是基线对齐，改为middle优点：简单，兼容缺：需要添加font-size:0,才可以完全垂直居中。需要注意，html#parent包裹img之间需要有换行或者空格 单个块级元素html &lt;div id = &quot;parent&quot;&gt;&lt;div id = &quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;(1)使用table-cell实现 #parent{display: table-cell; vertical-align: middle; } 优点： 简单，宽高不定，兼容性 缺点： 设置table-cell的元素。宽度和高度的值设置百分比无效，需要给他的父元素设置display: table才生效, 不感知margin，在父元素上设置table-row等属性，也会使其不感知height,设置float或position会对默认布局造成破坏（考虑为之增加一个父div定义float等属性内容溢出会自动撑开父元素(2)使用绝对定位实现（同水平居中的方式：子绝父相）(3)使用flex实现 #parent{display: flex; align-items: center} 或 #parent{display: flex} #son{align-self: center} 或 #parent{display: flex} #son{margin: auto 0 } 优：简单灵活 缺：PC兼容问题 垂直居中小结- 首先想到line-height，但是只能用于行内内容 - 其次考虑用vertical-align： middle - 绝对定位，代码多了点，但是胜在适用不同情况 - 移动端兼容性允许的情况下能用flex就用flex 水平垂直居中 (1) 行内/行内块级/图片#parent{height: 150px; line-height: 150px; text-align: center; font-size: 0; } #son{vertical: middle} 如果是块级元素，需要在son中加display：inline-block优点：代码简单，兼容（ie8+）缺点：只对行内内容有效； 需要添加font-size: 0; 才可以完全的垂直居中，不过需要注意的是，html中#parent包裹#son之间需要有换行或空格 (2) table-cell 使表格内容垂直对齐方式为middle，然后根据是行内内容还是块级内容采取不同的方式达到水平居中#parent{height:150px; width:200px; display: table-cell; vertical-align: middle; } 如果是行内元素加一行text-align: center#son{width: 100px; height:50px; } 如果是块级元素加一行 margin: 0 auto (3) button作为父元素改掉button的默认样式，再把需要居中的元素表现形式改为行内或行内块级button#parent{height: 150px; width: 200px; outline: none; border: none;} #son{display: inline-block } //button自带text-align：center - (4) 绝对定位 （子绝父相） (5) flex#parent{display: flex} #son{margin: auto } 或 #parent{display: flex; justify-content: center; align-items: center } 或 #parent{display: flex; justify-content: center} #son{align-self: center} (6) 视窗居中（vh为视口单位，视口即文档的可视部分，50vh就是视口高度的50/100，）#son{margin: 50vh auto 0; transform: translateY(-50%)} (7) 绝对居中（子绝父相+ 子元素中top&amp;bottom&amp;left&amp;right都设为0 margin：auto） 水平垂直居中小结- 一般情况下，用绝对定位加负边距，缺点是需要知道宽高，使用transform倒是可以不需要，但是兼容性不好（ie9+） - 其次就是绝对居中，让浏览器自动平分边距以达到水平垂直居中的目的 - 如果是行内/行内块级/图片这些，可以优先考虑line-height和vertical-align结合使用，不要忘了还有text-align - 移动端兼容性允许的话能用flex就用flex 两列布局 (1) 左列定宽，右列自适应1.1 利用float+margin实现html: 1234&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#left&#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right&#123; background-color: #0f0; height: 500px; margin-left:100px &#125; //注意:margin-left要大于等于#left的宽度 1.2 利用float+margin(fix)实现html: 123456&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right-fix&quot;&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415#left&#123; bacground-color: #f00; float: left; width: 100px; height: 500px;&#125; #right-fix&#123; float: right; width: 100%; margin-left: -100px; &#x2F;&#x2F;正值大于或等于#left的宽度，才能显示在同一行&#125; #right&#123;margin-left: 100px; &#x2F;&#x2F;大于或等于#left的宽度background-color: #0f0;height: 500px;&#125; 1.3 使用float+overflow实现html: 1234&lt;body&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011 #left&#123; background-color: $f00; float: left;width: 100px;height: 500px; &#125; #right&#123;background-color: #0f0;height: 500px;overflow: hidden; &#x2F;&#x2F;触发bfc达到自适应 &#125; 缺点：浮动脱离文档流，需要手动清除浮动，否则会产生高度塌陷1.4 使用table实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;&quot;right&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415 #parent&#123;width: 100%;display: table;height: 500px; &#125; #left&#123;width: 100px;background-color: #f00; &#125; #right&#123;background-color: #0f0; &#125; #left,#right&#123;display: table-cell; &#125; 1.5 使用绝对定位实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;&quot;right&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819 #parent&#123;position: relative; &#x2F;&#x2F;子绝父相 &#125; #left&#123;position: absolute;top: 0;left: 0;background-color: #f00;width: 100px;height: 500px; &#125; #right&#123;position: absolute;top: 0;left: 100px; &#x2F;&#x2F;值大于等于#left的宽度right: 0;background-color: #0f0;height: 500px; &#125; 1.6 使用flex实现html: 123456 &lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 12345678910111213 #parent&#123;width: 100%;height: 500px;display: flex; &#125; #left&#123;width: 100px;background-color: #f00; &#125; #right&#123;flex: 1; &#x2F;&#x2F;均分父元素剩余空间background-color: #0f0; &#125; 1.7 使用Grid实现html: 123456 &lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112 #parent &#123; width: 100%; height: 500px; display: grid; grid-template-columns: 100px auto; &#x2F;*设定2列就ok了,auto换成1fr也行*&#x2F; &#125; #left &#123;background-color: #f00; &#125; #right &#123;background-color: #0f0; &#125; (2)左列自适应，右列定宽 2.1 使用float+margin实现html: 123456 &lt;body&gt; &lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314151617#parent &#123; height: 500px; padding-left: 100px; &#x2F;&#x2F;抵消#left的margin-left以达到parent水平居中&#125;#left &#123; width: 100%; height: 500px; float: left; margin-left: -100px; &#x2F;&#x2F;正值等于#right的宽度 background-color: #f00;&#125;#right &#123; height: 500px; width: 100px; float; right; background-color: #0f0;&#125; 2.2 使用float+overflowhtml: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&gt; css: 123456789101112#left &#123; overflow: hidden &#x2F;&#x2F;触发bfc height: 500px; background-color: #f00;&#125;#right &#123; margin-left: 10px; &#x2F;&#x2F;margin需要定义在#right中 float: right; width: 100px; height: 500px; background-color: #0f0;&#125; 缺点：浮动脱离文档流，需要手动清除浮动，否则会发生高度塌陷，不支持ie62.3 使用table实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右侧定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; width: 100%; height: 500px; display: table;&#125;#left &#123; background-color: #f00; display: table-cell;&#125;#right &#123; width: 100px; background-color: #f0f0; display: table-cell;&#125; 缺点：margin失效，设置间隔比较麻烦2.4 使用绝对定位实现(子绝父相)html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819#parent &#123; position: relative;&#125;#left &#123; position: absolute; top: 0; left: 0; right: 100px; &#x2F;&#x2F;大于等于right的宽度 background-color: #f00; height: 500px;&#125;#right &#123; position: absolute; top: 0; right: 0; background-color: #0f0; width: 100px; height: 500px;&#125; 2.5 使用flex实现html: 123456&lt;body&gt; &lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112#parent &#123; height: 500px; display: flex;&#125;#left &#123; flex: 1; background-color: #f00;&#125;#right &#123; width: 100px; background-color; #0f0;&#125; 2.6 使用Grid实现html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列自适应&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#parent &#123; height: 500px; display: grid; grid-template-colums: auto 100px; &#x2F;&#x2F;设定2列，auto换成1fr也行&#125;#left &#123; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125; (3)一列不定，一列自适应(盒子宽度随着内容增加或减少发生变化，另一个盒子自适应) 3.1 使用float+overflow实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011#left &#123; margin-right: 10px; float: left; &#x2F;&#x2F;只设置浮动，不设宽度 height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; &#x2F;&#x2F;触发bfc height: 500px; background-color: #0f0;&#125; 3.2 使用flex实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent&#123; display: flex; &#125; #left &#123; &#x2F;*不设宽度*&#x2F; margin-right: 10px; height: 500px; background-color: #f00; &#125; #right &#123; height: 500px; background-color: #0f0; flex: 1; &#x2F;*均分#parent剩余的部分*&#x2F; &#125; 3.3 使用Grid实现 html: 123456&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列不定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; display: grid; grid-template-colums; auto 1fr; &#x2F;&#x2F;auto和1fr换一下顺序就是左列自适应，右列不定宽了&#125;#left &#123; margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0;&#125; 三列布局 1.1 两列定宽，一列自适应 (1)使用float+margin实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718192021#parent&#123; min-width: 310px; &#x2F;&#x2F;100+10+200,防止宽度不够，子元素换行&#125;#left&#123; margin-right: 10px; &#x2F;&#x2F;#left和#center间隔 float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right&#123; margin-left: 320px; &#x2F;&#x2F;等于#left和#center的宽度之和加上间隔 height: 500px; background-color: #0f0;&#125; (2)使用float+overflow实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819202122#parent&#123; min-width: 310px; &#x2F;&#x2F;100+10+200,防止宽度不够，子元素换行 &#125; #left&#123; margin-right: 10px; &#x2F;&#x2F;#left和#center间隔 float: left; width: 100px; height: 500px; background-color: #f00; &#125; #center&#123; margin-right: 10px; &#x2F;&#x2F;在此定义和#right的间隔 float: left; width: 200px; height: 500px; background-color: #eeff2b; &#125; #right&#123; overflow: hidden; &#x2F;&#x2F;触发bfc height: 500px; background-color: #0f0; &#125; (3)使用table实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516171819202122#parent&#123; width: 100%; height: 520px; &#x2F;&#x2F;抵消上下间距10*2的高度影响 margin: -10px 0; &#x2F;&#x2F;抵消上下边间距10的位置影响 display: table; &#x2F;&#x2F;左右两边间距大了一点，子元素改用paddig设置盒子间间距就没有这个问题 border-spacing: 10px; &#x2F;&#x2F;关键！！ 设置间距&#125;#left&#123; display: table-cell; width: 100px; background-color: #f00;&#125;#center&#123; display: table-cell; width: 200px; background-color: #eeff2b;&#125;#right&#123; display: table-cell; background-color: #0f0;&#125; (4)使用flex实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718#parent&#123; height: 500px; display: flex;&#125;#left&#123; margin-right: 10px; &#x2F;&#x2F;间距 width: 100px; background-color: #f00;&#125;#center&#123; margin-right: 10px; &#x2F;&#x2F;间距 width: 200px; background-color: @eeff2b;&#125;#right&#123; flex: 1; &#x2F;&#x2F;均分parent剩余的部分达到自适应 background-color: #0f0;&#125; (5)使用Grid实现 html: 1234567&lt;body&gt;&lt;div id &#x3D; &quot;parent&quot;&gt; &lt;div id &#x3D; &quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;center&quot;&gt;中间定宽&lt;&#x2F;div&gt; &lt;div id &#x3D; &quot;right&quot;&gt;右列自适应&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516#parent &#123; height: 500px; display: grid; grid-template-columns: 100px 200px auto; &#x2F;*设置3列,固定第一第二列的宽度,第三列auto或者1fr*&#x2F; &#125; #left &#123; margin-right: 10px; &#x2F;*间距*&#x2F; background-color: #f00; &#125; #center &#123; margin-right: 10px; &#x2F;*间距*&#x2F; background-color: #eeff2b; &#125; #right &#123; background-color: #0f0; &#125; 1.2两侧定宽，中间自适应 (1)双飞翼布局 html: 12345678910111213&lt;body&gt; &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt; &lt;!--中间栏需要放在前面--&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;center&quot;&gt; &lt;div id&#x3D;&quot;center_inbox&quot;&gt;中间自适应&lt;&#x2F;div&gt; &lt;hr&gt; &lt;!--方便观察原理--&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233343536#header &#123; height: 60px; background-color: #ccc; &#125; #left &#123; float: left; width: 100px; height: 500px; margin-left: -100%; &#x2F;*调整#left的位置,值等于自身宽度*&#x2F; background-color: #f00; opacity: 0.5; &#125; #center &#123; height: 500px; float: left; width: 100%; background-color: #eeff2b; &#125; #center_inbox&#123; height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; &#x2F;*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*&#x2F; &#125; #right &#123; float: left; width: 200px; height: 500px; margin-left: -200px; &#x2F;*使right到指定的位置,值等于自身宽度*&#x2F; background-color: #0f0; opacity: 0.5; &#125; #footer &#123; clear: both; &#x2F;*注意清除浮动!!*&#x2F; height: 60px; background-color: #ccc; &#125; (2)圣杯布局 html: 123456789101112&lt;body&gt; &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;!--#center需要放在前面--&gt; &lt;div id&#x3D;&quot;center&quot;&gt;中间自适应 &lt;hr&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;左列定宽&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;右列定宽&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 1234567891011121314151617181920212223242526272829303132333435363738394041#header&#123; height: 60px; background-color: #ccc; &#125; #parent &#123; box-sizing: border-box; height: 500px; padding: 0 215px 0 115px; &#x2F;*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*&#x2F; &#125; #left &#123; margin-left: -100%; &#x2F;*使#left上去一行*&#x2F; position: relative; left: -115px; &#x2F;*相对定位调整#left的位置,正值大于或等于自身宽度*&#x2F; float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5; &#125; #center &#123; float: left; width: 100%; &#x2F;*由于#parent的padding,达到自适应的目的*&#x2F; height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b; &#125; #right &#123; position: relative; left: 215px; &#x2F;*相对定位调整#right的位置,大于或等于自身宽度*&#x2F; width: 200px; height: 500px; margin-left: -200px; &#x2F;*使#right上去一行*&#x2F; float: left; background-color: #0f0; opacity: 0.5; &#125; #footer&#123; height: 60px; background-color: #ccc; &#125; (3)使用Grid实现 (4)使用table实现 (5)使用flex实现 (6)使用position 多列布局 等宽布局 1.1四列等宽 (1)使用float实现 html: 12345678&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 123456789101112131415161718#parent &#123; margin-left: -20px; &#x2F;*使整体内容看起来居中,抵消padding-left的影响*&#x2F; &#125; .column&#123; padding-left: 20px; &#x2F;*盒子的边距*&#x2F; width: 25%; float: left; box-sizing: border-box; border: 1px solid #000; background-clip: content-box; &#x2F;*背景色从内容开始绘制,方便观察*&#x2F; height: 500px; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：需要手动清浮动，否则会产生高度塌陷 (2)使用table实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213141516#parent &#123; height: 540px; &#x2F;*抵消上下边20*2间距的高度影响*&#x2F; display: table; margin: -20px 0; &#x2F;*抵消上下边20*2间距的位置影响*&#x2F; &#x2F;*两边离页面间距较大,改用子元素设置padding来当成间隔就不会有这样的问题*&#x2F; border-spacing: 20px; &#x2F;*设置间距*&#x2F; &#125; .column&#123; display: table-cell; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：margin失效 (3)使用flex实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415#parent &#123; margin-left: -15px; &#x2F;*使内容看起来居中*&#x2F; height: 500px; display: flex; &#125; .column&#123; flex: 1; &#x2F;*一起平分#parent*&#x2F; margin-left: 15px; &#x2F;*设置间距*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 1.2多列等宽 (1)使用float实现 html: 12345678910&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; height: 500px; &#125; .column&#123; float: left; &#x2F;*添加浮动*&#x2F; width: 16.66666666666667%; &#x2F;*100÷列数,得出百分比*&#x2F; height: 500px; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：需手动清浮动，否则会产生高度塌陷 (2)使用table实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 1234567891011121314#parent &#123; width: 100%; height: 500px; display: table; &#125; .column&#123; display: table-cell; &#x2F;*无需关注列数,单元格自动平分*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; 缺点：margin失效，设置间隔比较麻烦 (3)使用flex实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; height: 500px; display: flex; &#125; .column&#123; flex: 1; &#x2F;*无需关注列数,一起平分#parent*&#x2F; &#125; .column:nth-child(odd)&#123; background-color: #f00; &#125; .column:nth-child(even)&#123; background-color: #0f0; &#125; (4)使用Grid实现 html: 12345678910&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;5 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;6 &lt;p&gt;我是文字我是文字我输文字我是文字我是文字&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112#parent &#123; height: 500px; display: grid; grid-template-columns: repeat(6,1fr); &#x2F;*6就是列数*&#x2F;&#125;.column&#123;&#125;.column:nth-child(odd)&#123; background-color: #f00;&#125;.column:nth-child(even)&#123; background-color: #0f0;&#125; 九宫格布局(1)使用table实现html: 12345678910111213141516171819&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 12345678910111213#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: table; &#125; .row &#123; display: table-row; &#125; .item &#123; border: 1px solid #000; display: table-cell; &#125; (2)使用flex实现 html: 12345678910111213141516171819&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;css: 123456789101112131415#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: flex; flex-direction: column; &#125; .row &#123; display: flex; flex: 1; &#125; .item &#123; flex: 1; border: 1px solid #000; &#125; (3)使用Grid实现html: 12345678910111213&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;8&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;9&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css 1234567891011#parent &#123; width: 1200px; height: 500px; margin: 0 auto; display: grid; grid-template-columns: repeat(3, 1fr); &#x2F;*等同于1fr 1fr 1fr,此为重复的合并写法*&#x2F; grid-template-rows: repeat(3, 1fr); &#x2F;*等同于1fr 1fr 1fr,此为重复的合并写法*&#x2F; &#125; .item &#123; border: 1px solid #000; &#125; 栅格系统 全屏布局 (1)绝对定位实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233html, body, #parent &#123;height: 100%;overflow: hidden;&#125;#parent &gt; div &#123; border: 1px solid #000;&#125;#top &#123; position: absolute; top: 0; left: 0; right: 0; height: 100px;&#125;#left &#123; position: absolute; top: 100px; &#x2F;*值大于等于#top的高度*&#x2F; left: 0; bottom: 50px; &#x2F;*值大于等于#bottom的高度*&#x2F; width: 200px;&#125;#right &#123; position: absolute; overflow: auto; left: 200px; &#x2F;*值大于等于#left的宽度*&#x2F; right: 0; top: 100px; &#x2F;*值大于等于#top的高度*&#x2F; bottom: 50px; &#x2F;*值大于等于#bottom的高度*&#x2F;&#125;#bottom &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 50px;&#125; (2)flex html: 12345678910&lt;body&gt; &lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;middle&quot;&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; css: 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;html,body,#parent&#123; height:100%;&#125;#parent &#123; display: flex; flex-direction: column;&#125;#top &#123; height: 100px;&#125;#bottom &#123; height: 50px;&#125;#middle &#123; flex: 1; display: flex;&#125;#left &#123; width: 200px;&#125;#right &#123; flex: 1; overflow: auto;&#125; (3)Grid实现 html: 12345678&lt;body&gt;&lt;div id&#x3D;&quot;parent&quot;&gt; &lt;div id&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; css: 123456789101112131415161718192021222324252627282930313233343536*&#123; margin: 0; padding: 0;&#125;html, body, #parent &#123; height: 100%;&#125;#parent &#123; width: 100%; height: 100%; display: grid; &#x2F;*分成2列,第一列宽度200px,第二列1fr平分剩余的部分,此处换成auto也行*&#x2F; grid-template-columns: 200px 1fr; &#x2F;*分成3行,第一行高度100px,第二行auto为自适应,此处换成1fr也行,第3行高度为50px*&#x2F; grid-template-rows: 100px auto 50px; &#x2F;*定义网格区域分布*&#x2F; grid-template-areas: &quot;header header&quot; &quot;aside main&quot; &quot;footer footer&quot;;&#125;#parent&gt;div&#123; border: 1px solid #000;&#125;#top&#123; grid-area: header; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#left&#123; grid-area: aside; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#right&#123; grid-area: main; &#x2F;*指定在哪个网格区域*&#x2F;&#125;#bottom&#123; grid-area: footer; &#x2F;*指定在哪个网格区域*&#x2F;&#125; 补充 盒子模型:标准（box-sizing:content-box）/怪异(box-sizing:border-box)标准盒: 元素的宽等于 style里的width+margin+border+padding。 width=content（不包括padding和border）怪异盒: 元素的宽 等于style里的width宽度。 width= content+padding+border em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小——MDNem根据父级的font-size变化 rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDNrem根据根的font-size变化 行内元素和块级元素行内元素（display：inline）：宽度和高度由内容决定块级元素（display：block）：默认宽度由父元素决定（平时经常使用display：inline-block 使它拥有更多的状态） 绝对定位和相对定位position:absolute 相对于元素最近的已定位的祖先元素position:relative 相对定位是相对于元素在文档中的初始位置 flex布局Flex布局元素，称为Flex容器，简称”容器”。它的所有子元素自动成为容器元素，简称”项目”(1)flex-direction:决定主轴的方向（即项目的排列方式） display: flex; flex-direction: row; (主轴水平方向，起点在左侧) flex-direction: row-reverse(起点在右侧)flex-direction: column(主轴垂直方向，起点在上沿) flex-direction: column-reverse(主轴在垂直方向，起点在下沿)(2)flex-wrap: 默认情况下，项目都排在一条线上（轴线上） flex-wrap: wrap(换行，第一行在上面) flex-wrap: wrap-reverse;(换行，第一行在下面)(3)flex-flow: flex-direction和flex-wrap的简写，默认为row,nowrap(4)justify-content: 定义了项目在主轴上的对齐方式 justify-content： flex-start （默认:左对齐）flex-end (右对齐) center(居中) space-between(两端对齐，项目之间的间隔相等) space-around(每个项目两侧的间距相等)(5)align-items: 定义项目交叉轴上如何对齐(垂直方向) flex-start (交叉轴起点对齐) flex-end (交叉轴终点对齐) center(垂直方向，中间开始) baseline(项目第一行文字的基线对齐) stretch （默认值，如果项目未设置高度或设为auto,将占满整个容器的高度)(6)align-content: 多行轴线对齐 (用法同align-items)(7)flex项目属性 1.order 定义项目排列顺序 order：number(数值越小越靠前，默认为0) 2.flex-grow 定义项目放大比例 flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推） 3.flex-shrink 定义项目缩小比例 flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小） 4.flex-basis 定义项目自身大小 flex-basis ：number/auto （默认auto) 5.flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto 6.align-self 项目自身对齐 BFCBFC:格式化上下文，是一个独立的渲染区域，让处于BFC的内部的元素与外部的元素隔离，使内外元素的定位不会相互影响如何产生: display:inline-block/flex/table-cell/inline-flex; position:absolute/fixed作用: 解决上外边距重叠（重叠的两个box都开启bfc）解决浮动引起的高度塌陷（容器盒子开启bfc） 解决文字焕然图片（左边图片div，右边文字容器p开启bfc） 水平居中和垂直居中 水平居中：行内：display: inline-block块级：margin: 0 auto; (要设宽度) flex：display: flex; justify-content: center;(在主轴上的对齐方式) 垂直居中：行高=元素高：line-height: height;flex: dispkay: flex; align-items: center; JS 几条基本规范 不要在同一行声明多个变量 请使用===/！==来比较true/false或者数值 使用对象字面量替代new Array这种形式 引用方法 行内引入（不推荐） 内部引入 外部引入 基本数据类型 Undefined,Null,Boolean,Number,String,新增:Symbol 数组操作 map: 遍历数组，对元素重新组装，生成新数组 forEach: 遍历所有元素 filter: 过滤符合条件的元素 //返回数组 some: 判断是否有至少一个元素符合条件（一个满足即可） every: 判断所有元素是否都符合条件 sort: 排序 slice(start, end): 返回截断后的新数组，不改变原数组 splice(start, number, value…): 返回删除元素组成的数组，value 为插入项，改变原数组 内置对象 Object是JS中所有对象的父对象 数据封装对象: Object,Array,Boolean,Number和String 其他对象: Function,Arguments,Math,Date,RegExp,Error get和post请求在缓存方面的区别 get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 闭包(closure) 一个作用域可以访问另外一个函数内部的局部变量 闭包的作用: 延伸变量的作用范围，使变量始终保持在内存中（好处: 能够实现封装和缓存） 坏处: 消耗内存，不正当使用会造成内存溢出的问题（在退出函数之前，将不使用的局部变量全部删除） 闭包经典问题题目1: 12345for(var i &#x3D; 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); &#125; //3个3。 for循环是同步，先执行三遍for，i变成了3，然后再执行异步代码setTimeout，这时候输出i，3个3 12345for(let i &#x3D; 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; //0,1,2 在这里，每个let和代码块结合起来形成块级作用域，当setTimeout打印时，会寻找最近的块级作用域中的i，依次打印出0 1 2 题目2: 12345678910var name &#x3D; &quot;This window&quot;var object &#x3D; &#123; name: &quot;My object&quot; getNameFunc: function()&#123; return function()&#123; return this.name &#125; &#125; &#125;console.log(object.getNameFunc()()) 解释:类似于: 123456789var f &#x3D; object.getNameFunc()var f &#x3D; function()&#123; return this.name &#125;求f()funtion()&#123; return this.name&#125;() &#x2F;&#x2F; 输出“This window” 立即执行函数中的this指向window 题目3: 1234567891011 var name &#x3D; &quot;This window&quot; var object &#x3D; &#123; name: &quot;My object&quot; getNameFunc: function()&#123;var that &#x3D; this return function()&#123; return that.name &#125; &#125; &#125; console.log(object.getNameFunc()()) 解释: 类似于: 123456789var f &#x3D; object.getNameFunc() var f &#x3D; function()&#123; return that.name &#125;求f() funtion()&#123; return that.name&#125;() &#x2F;&#x2F; 输出“My object” 作用域 全局作用域/函数作用域 原型 原型规则(1)对象，数组，函数，都可以自由扩展属性(2)对象，数组，函数，都有一个proto属性(3)所有函数都有一个prototype属性(4)obj.proto === Object.prototype(5)当试图得到一个对象的属性时，如果这个对象本身没有这个属性，那么就会去它的proto（即它的构造函数的prototype）中寻找 如何准确判断一个变量是数组类型？instanceofinstanceof的原理就是利用了原型链，当执行arr instanceof Array时，会从arr的proto一层一层往上找，看是否能查到Array的prototype 写出一个原型链继承的例子（封装“数据和算法”的例子） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;封装二叉搜索树function BinarySearchTree()&#123; &#x2F;&#x2F;内部类，节点 function Node(key)&#123; this.key &#x3D; key this.left &#x3D; null this.right &#x3D; null &#125;&#x2F;&#x2F;属性this.root &#x3D; null&#x2F;&#x2F;方法 &#x2F;&#x2F;插入数据:对外给用户调用的方法BinarySearchTree.prototype.insert &#x3D; function(key)&#123; &#x2F;&#x2F;根据key创建节点 var newNode &#x3D; new Node(key) &#x2F;&#x2F;判断根节点是否有值 if(this.root &#x3D;&#x3D; null)&#123; this.root &#x3D; newNode &#125; else &#123; this.insertNode(this.root, newNode) &#125;&#125;BinarySearchTree.prototype.insertNode &#x3D; function(node, newNode)&#123; if(newNode.key &lt; node.key)&#123; &#x2F;&#x2F;向左查找 if(node.left &#x3D;&#x3D; null)&#123; node.left &#x3D; newNode &#125;else &#123; this.insertNode(node.left, newNode) &#125; &#125; else &#123; &#x2F;&#x2F;向右查找 if(node.right &#x3D;&#x3D; null)&#123; node.right &#x3D; newNode &#125;else &#123; this.insertNode(node.right, newNode) &#125; &#125;&#125;&#125;&#x2F;&#x2F;测试var bst &#x3D; new BinarySearchTree()bst.insert(11)bst.insert(7)bst.insert(15)bst.insert(5&#125;console.log(bst) 描述new一个对象的过程 1.创建一个对象 2.获得构造函数的prototype属性，并把prototype赋值给新对象的proto，this指向这个新对象 3.执行构造函数。返回构造函数的内容 组件化开发/模块化开发 组件化开发 –&gt;功能拆分，组件封装，以达到组件复用性，增强代码可读性，提高维护性 模块化开发 –&gt;避免变量污染（不用全局变量，不会带来污染/覆盖），命名冲突， 提高代码复用率，提高可维护性， 方便依赖关系管理(export暴露出去，引用谁，再执行，依赖关系明确) –&gt;AMD (异步模块规范) 先define(…)才能require(…) –&gt;CommonJS (nodejs模块化规范) 要先配置webpack （webpack的配置：context,entry,output,（构建工具：grunt,gulp,fis,webpack））CommonJS不会异步加载JS，而是一次性加载进来 –&gt;使用场景 需要异步加载JS，使用AMD使用了npm，建议使用CommonJS 异步和单线程 JS是单线程的语言，如果要同时处理多件事，要用异步 –&gt;异步：所有的“等待的情况”都需要异步（定时任务：setTimeout setInterval。 网络请求：ajax请求，动态加载。 事件绑定（可以当作异步来理解）） –&gt;同步和异步的区别？ 阻塞。 alert（同步） setTimeout（异步） Ajax (XMLHttpRequest，状态码说明，跨域) 手写一个ajax请求 12345678910 var xhr &#x3D; new XMLHttpRequest() xhr.open(&#39;GET&#39;,&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;first&#39;) xhr.onreadystatuschange &#x3D; function()&#123; if (xhr.readystatus &#x3D;&#x3D; 4)&#123; if(xhr.status &#x3D;&#x3D; 200)&#123; alert(xhr.responseText) &#125;&#125; &#125; xhr.send(null) 状态码xhr.readystatus: 0(还没发送send请求),1（正在发送请求）,2（send（）方法执行完成，已接收全部内容）,3（正在解析响应内容）,4（完成，响应内容解析完成，可以在客户端调用）xhr.status: 2xx 成功处理请求 3xx 需要重定向 4xx 客户端请求错误（如404） 5xx 服务器端错误 ajax（同源政策）ajax只能向自己的服务器发送请求（同源：协议，域名，端口都相同）此时，有跨域的需求 —&gt;跨域？ —&gt;有三个标签允许跨域加载资源, , ---->而script可以使用JSONP方式跨域（json with padding） 1.将不同源的服务器端的地址写在script标签里的src里 2.服务器端响应数据必须是一个函数的调用，要发送给客户端的数据需要作为函数调用的参数 3.客户端全局作用域下定义函数fn 4.在fn函数内部对服务器端返回的数据进行处理 ---->跨域方法2: CORS 跨域资源共享 服务器端操作 设置http header ----->跨域方法3: 两台服务器之间操作 存储 请描述一下cookie，sessionStorage和localStorage的区别 1.容量。cookie不能超4k 。 sessionStorage和localStorage可以达到5M或更大 2.所有的http请求都携带cookie 3.数据有效期不同，sessionStorage在会话结束时（浏览器关闭时），会自动清理。cookie在设置的过期时间之前都有效。localStorage始终有效 ----> cookie 客户端第一次请求服务器，服务端响应cookie 第二次：客户端携带cookie请求服务器 图片的预加载和懒加载 预加载: 提前加载图片，当用户需要查看时可直接从本地缓存中渲染 懒加载: 作为服务器前端的优化，减少请求次数或延迟请求数 预加载增加服务器前端压力，懒加载对服务器有一定的缓解压力作用 mouseover和mouseenter的区别 不论鼠标指针穿过被选元素或其子元素，都会触发mouseover事件。对应mouseout（冒泡） 只有在鼠标指针穿过被选元素时，才会触发mouseenter事件。对应mouseleave 解决异步回调地狱 promise(key word: resolve,reject,then)、generator、async/await（将异步代码写成同步的形式） await 暂停当前整个异步函数向下执行，直到promise返回结果（这里的promise指的是await后面的promise对象，await后面只能写promise对象） 对this的理解 this总是指向函数的直接调用者 如果有new关键字，this指向new出来的那个对象 改变this指向 --->箭头函数: 箭头函数的this始终指向函数定义时的this，而非执行时 --->在函数内部使用_this = this --->apply,call,bind apply和call: 调用函数，改变this指向，传入参数不同，call接受的是若干个参数列表，apply接收的是一个包含多个参数的数组。 bind: 不会调用函数，改变this指向 React 其他 项目经验","categories":[],"tags":[]},{"title":"NEXTJS PROJECT项目学习","slug":"NEXTJS-PROJECT项目学习","date":"2020-06-05T09:04:36.000Z","updated":"2020-06-09T05:49:21.325Z","comments":true,"path":"2020/06/05/NEXTJS-PROJECT项目学习/","link":"","permalink":"http://yoursite.com/2020/06/05/NEXTJS-PROJECT%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"React学习","slug":"React学习01","date":"2020-06-03T05:51:40.000Z","updated":"2020-07-03T03:32:16.531Z","comments":true,"path":"2020/06/03/React学习01/","link":"","permalink":"http://yoursite.com/2020/06/03/React%E5%AD%A6%E4%B9%A001/","excerpt":"*React - 1、视图层框架 —&gt; 一个构建用户界面的框架 —&gt; 声明式的框架（比如jquery，就是命令式的，指挥哪一个选择器，选择哪一个元素，然后怎么操作他） —&gt;只要定义好数据和DOM之间的对应关系就可以了 —&gt; 数据驱动DOM，再用事件反馈给数据 - 2、组件化开发 —&gt; 组件组合而不是继承来对代码进行封装（组件组合更加灵活，也不会收到继承里的约束） —&gt; 主要属性： state&amp;&amp;props（state:状态、数据， props:用于父子组件的通信，子组件通过props拿到父组件传来的数据或方法（react组件间的数据传递方式是由上向下的，需要父组件在props里把操作的方法也传个子组件，通过一种类似回调的方式，让父组件的数据状态发生改变）） - 3、生命周期 —&gt; 一个组件从建立，到存在，最后到销毁的整个过程 - 4、JSX表达式 —&gt; 一种JS扩展的表达式 —&gt; 带有逻辑的标记语法，有别于HTML模版（更像是一个脚本，可以随时改变，更加灵活） —&gt; 对样式，逻辑表达式和事件的支持 - 5、虚拟DOM （是一种埋在框架底层的机制）（优点：1、操作DOM前对数据进行对比，只有数据变化的时候，才去操作DOM 2、会整合DOM操作） —&gt;只有在必要的时候才会去操作DOm，通过减少这种低效的操作来增加性能 —&gt; 在react中，会把定义好的JSX标记最终转换成一个虚拟的DOM，存在内存里，（因为内存的读取的速度要比操作DOM快得多） —&gt; 如果用户做了对DOM产生变化的操作（虚拟DOM比较操作前后的数据差异） —&gt; 如果有数据差异，统一操作DOM一次，如果比较之后没有差异，就不会操作DOM了 React总结 简洁：不是指语法，而是当业务内容复杂时，单向数据流和组件化的组合方式会从很大程度上降低问题的复杂度 灵活：在React中可以把一切理解为js，这样在操作的时候会减少很多的束缚，另外，组件提供了多种嵌套方式，数据驱动，生命周期等特点，让开发变得更顺畅 高效：虚拟DOM的存在，通过减少和优化对DOM的操作，让react在浏览器中有更好的性能表现 but –&gt; 思维转换：比如jsx，单向数据流在之前的原生开发中都没有接触过 –&gt; 要依赖生态：比如react-router、react-redux等，要学习更多的内容，也更加复杂 –&gt; 变动频繁：不向前兼容","text":"*React - 1、视图层框架 —&gt; 一个构建用户界面的框架 —&gt; 声明式的框架（比如jquery，就是命令式的，指挥哪一个选择器，选择哪一个元素，然后怎么操作他） —&gt;只要定义好数据和DOM之间的对应关系就可以了 —&gt; 数据驱动DOM，再用事件反馈给数据 - 2、组件化开发 —&gt; 组件组合而不是继承来对代码进行封装（组件组合更加灵活，也不会收到继承里的约束） —&gt; 主要属性： state&amp;&amp;props（state:状态、数据， props:用于父子组件的通信，子组件通过props拿到父组件传来的数据或方法（react组件间的数据传递方式是由上向下的，需要父组件在props里把操作的方法也传个子组件，通过一种类似回调的方式，让父组件的数据状态发生改变）） - 3、生命周期 —&gt; 一个组件从建立，到存在，最后到销毁的整个过程 - 4、JSX表达式 —&gt; 一种JS扩展的表达式 —&gt; 带有逻辑的标记语法，有别于HTML模版（更像是一个脚本，可以随时改变，更加灵活） —&gt; 对样式，逻辑表达式和事件的支持 - 5、虚拟DOM （是一种埋在框架底层的机制）（优点：1、操作DOM前对数据进行对比，只有数据变化的时候，才去操作DOM 2、会整合DOM操作） —&gt;只有在必要的时候才会去操作DOm，通过减少这种低效的操作来增加性能 —&gt; 在react中，会把定义好的JSX标记最终转换成一个虚拟的DOM，存在内存里，（因为内存的读取的速度要比操作DOM快得多） —&gt; 如果用户做了对DOM产生变化的操作（虚拟DOM比较操作前后的数据差异） —&gt; 如果有数据差异，统一操作DOM一次，如果比较之后没有差异，就不会操作DOM了 React总结 简洁：不是指语法，而是当业务内容复杂时，单向数据流和组件化的组合方式会从很大程度上降低问题的复杂度 灵活：在React中可以把一切理解为js，这样在操作的时候会减少很多的束缚，另外，组件提供了多种嵌套方式，数据驱动，生命周期等特点，让开发变得更顺畅 高效：虚拟DOM的存在，通过减少和优化对DOM的操作，让react在浏览器中有更好的性能表现 but –&gt; 思维转换：比如jsx，单向数据流在之前的原生开发中都没有接触过 –&gt; 要依赖生态：比如react-router、react-redux等，要学习更多的内容，也更加复杂 –&gt; 变动频繁：不向前兼容 JSX语法 JSX基本语法12345let jsx &#x3D; &lt;div&gt; jsx...&lt;&#x2F;div&gt;ReactDOM.render( jsx, document.getElementById(&#39;app&#39;)) ReactDOM上有一个render的方法，传第一个是react的内容，第二个是选择器（document。getElementById((‘app’)) ReactDOM - 样式处理1、行内选择器 123456789let style &#x3D; &#123; color: &#39;red&#39;, fontSize: &#39;20px&#39;&#125;let jsx &#x3D; &lt;div style &#x3D; &#123;style&#125;&gt; jsx...&lt;&#x2F;div&gt;ReactDOM.render( jsx, document.getElementById(&#39;app&#39;)) 2、className=“xxx” （因为class和类的class重了） - 数据逻辑处理12345678910111213141516171819let name &#x3D; &#39;white-zero&#39;let names &#x3D; [A,B,C]let flag &#x3D; &#39;true&#39;let jsx &#x3D; ( &lt;div&gt; &#123;&#x2F;*条件判断*&#x2F;&#125; &#123; flag ? &lt;p&gt;I am &#123;name&#125;&lt;&#x2F;p&gt; : &lt;p&gt;I am not &#123;name&#125; &lt;&#x2F;p&gt; &#125; &#123;&#x2F;*数组循环*&#x2F;&#125; &#123; names.map((name,index) &#x3D;&gt; &lt;p key&#x3D;&#123;index&#125;&gt;I am &#123;name&#125;&lt;&#x2F;p&gt;) &#125; &lt;&#x2F;div&gt;)ReactDOM.render( jsx, document.getElementById(&#39;app&#39;)) 组件 组件基本结构1.函数类型的组件(hooks之后都可以用这种方式吧) 123 function Component()&#123;return &lt;div&gt;hello world&lt;&#x2F;div&gt; &#125; 2.基于类的组件 12345 class xxx extends React.Component&#123;render()&#123; return &lt;div&gt;hello world&lt;&#x2F;div&gt; &#125; &#125; state&amp;&amp;props1、state &amp;&amp; setState 12345678910111213141516 class xxx extends React.Component&#123;constructor(props)&#123; super(props) this.state &#x3D; &#123;name &#x3D; &#39;white-zero&#39; &#125;&#125; render()&#123; setTimeout(()&#x3D;&gt;&#123; this.setState(&#123; name : &#39;test&#39; &#125;) &#125;) return &lt;h1&gt;I am &#123;this.state.name&#125;&lt;&#x2F;h1&gt; &#125; &#125; 2、props 1234567891011121314 class Component extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return &lt;h1&gt;I am &#123;this.props.name&#125;&lt;&#x2F;h1&gt; &#125; &#125; ReactDOM.render(&lt;div&gt; &lt;Component name &#x3D; &quot;white-zero&quot;&#x2F;&gt;&lt;&#x2F;div&gt;,document.getElementById(&#39;app&#39;) ) 事件处理1.事件处理方式1 123456789101112131415161718192021222324 class xxx extends React.Component&#123; constructor(props)&#123; super(props) this.state &#x3D; &#123; name &#x3D; &#39;white-zero&#39;, age &#x3D; 18 &#125;this.handleClick &#x3D; this.handleClick.bind(this)&#x2F;&#x2F;绑定this除了用上面的方法，还可以直接在onClick里使用箭头函数 &#125; handleClick()&#123; this.setState( age : this.state.age + 1) &#125; render()&#123; return (&lt;h1&gt;I am &#123;this.state.name&#125;&lt;&#x2F;h1&gt;&lt;p&gt;I am &#123;this.state.age&#125; years old&lt;&#x2F;p&gt; &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;加一岁&lt;&#x2F;button&gt;&#x2F;&#x2F;&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; &#123;this.handleClick(e)&#125;&#125;&gt;加一岁&lt;&#x2F;button&gt; ） &#125; &#125; 2、事件处理方式2 123456789101112131415161718192021222324252627 class xxx extends React.Component&#123; constructor(props)&#123; super(props) this.state &#x3D; &#123; name &#x3D; &#39;white-zero&#39;, age &#x3D; 18 &#125; &#125; handleClick()&#123; this.setState( age : this.state.age + 1 ) &#125; onValueChange()&#123; this.setState(&#123;age : e.target.value &#125;) &#125; render()&#123; return ( &lt;h1&gt;I am &#123;this.state.name&#125;&lt;&#x2F;h1&gt; &lt;p&gt;I am &#123;this.state.age&#125; years old&lt;&#x2F;p&gt; &lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; &#123;this.handleClick(e)&#125;&#125;&gt;加一岁&lt;&#x2F;button&gt; &lt;input type&#x3D;&quot;text&quot; onChange &#x3D; &#123;(e) &#x3D;&gt; &#123;this.onValueCHange(e)&#125;&#125;&gt; ） &#125; &#125; 组件的组合方式1、纯组件形式 12345678910111213class Component extends React.Component&#123; render()&#123; return &lt;div&gt;hello world&lt;&#x2F;div&gt; &#125;&#125;class CC extends React.Component&#123; render()&#123; return &lt;div&gt; &lt;Component&#x2F;&gt; &lt;&#x2F;div&gt; &#125;&#125; 2、容器组件形式方式1: 123456789101112131415161718 class Title extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return &lt;div&gt; &#123;this.props.title&#125; &lt;&#x2F;div&gt; &#125; &#125; class CC extends React.Component&#123; render()&#123; return &lt;div&gt; &lt;Title title&#x3D;&quot;题目&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &#125; &#125; 方式2: 1234567891011121314151617181920 class Title extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;&#x2F;div&gt; &#125; &#125; class CC extends React.Component&#123; render()&#123; return &lt;div&gt; &lt;Title&gt; &lt;span&gt;App span&lt;&#x2F;span&gt;&lt;&#x2F;Title&gt; &lt;&#x2F;div&gt; &#125; &#125; 组件间的数据通信1、父组件传给子组件(props)2、子组件传给父组件(通过在父组件定义改变数据的方法，然后在子组件中用props继承父组件的方法以改变父组件)3、兄弟组件间传值（child1传到父组件，再从父组件传到child2，实现child1改变child2的状态） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 class Father extends React.Component&#123; constructor(props)&#123; super(props) this.state &#x3D; &#123; child2BgColor: &#39;#999&#39;, child1BgColor: &#39;#666&#39; &#125; &#125; onChild2BgColorChange(color)&#123; this.setState(&#123; child2BgColor: color &#125;)&#125; render(props)&#123; return ( &lt;div&gt; &lt;Child1 child1BgColor&#x3D;&#123;this.state.child1BgColor&#125; changeChild2Color&#x3D;&#123;(color) &#x3D;&gt; &#123;this.onChild2BgColorChange(color)&#125;&#125; &#x2F;&gt; &lt;Child2 bgColor&#x3D;&#123;this.state.child2BgColor&#125;&#x2F;&gt; &lt;&#x2F;div&gt; ) &#125; &#125; class Child1 extends React.Component&#123; constructor(props)&#123; super(props) &#125; handleClick()&#123; this.props.changeChild2Color(&#39;red&#39;) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;child1: &#123;this.props.child1BgColor&#125;&lt;h1&gt; &lt;button onClick &#x3D; &#123;(e)&#x3D;&gt;&#123;this.handleClick(e)&#125; &#125;&gt;改变child2的背景颜色&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; ) &#125; &#125; class Child2 extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div style&#x3D;&#123;&#123;background: this.props.bgColor&#125;&#125;&gt; &lt;h1&gt;Child2背景颜色:&#123;this.props.bgColor&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; ) &#125; &#125; 生命周期 生命周期的概念：一个组件从建立，到存在，最后到销毁的整个过程 生命周期的作用 生命周期的节点 —&gt;Mounting：挂载阶段 —&gt;Updating：运行时阶段（主要处理的是状态更新时引起的变化） —&gt;Unmounting：卸载阶段 —&gt;Error Handling：错误处理(不管逻辑错误) 执行顺序 加载时： 1、constructor 2、componentWillMount(一般用来执行异步函数) 3、render 4、componentDidMount（组件已经挂载成功了） 更新时： 5、(componentWillReceiveProps) 要接收父组件的props时 5、shouldComponentUpdate（return一个true/false，为true后面才继续执行，一般不动，因为render里面虚拟DOM也会自己判断一次，组件前后有没有更新） 6、componentWillUpdate 7、render 8、componentDidUpdate 9、componentWillUnmount（组件即将销毁，比如做了定时器，在组件消失的时候，要删除以减少内存占用时使用） Router和React-Router Router原理 简单说就是允许页面之间相互跳转并记录跳转的关系且能原路返回的机制 路由历史 ： 栈结构，通过入栈和出栈的方式记录页面的访问过程 路由跳转 ： 负责不同页面的跳转动作，并且可以传递参数 事件 ： 用来打开新页面或返回上一个页面，触发的逻辑 常见Router 页面Router(页面重新加载/渲染) -&gt; window.location.href = ‘http://www.baidu.com&#39; -&gt; history.back() Hash Router（只有Hash值在发生变化（跳到某个hash状态上），页面并没有重新加载，实现单页应用使用的最早的一种技术，兼容性不错） -&gt; window.location.href = ‘#test1’ -&gt; window.onhashchange = function(){ console.log(&apos;current hash:&apos;, window.location.hash) } H5 Router（与Hash Router相比，他既能操作Hash，又能操作路径，适用于单页应用） -&gt; history.pushState(‘test’,’Title’,’#test1’) -&gt; history.pushState(&apos;test&apos;,&apos;Title&apos;,&apos;/user/index&apos;) -&gt; history.replaceState(‘test’,null.’/index/test’) （替换当前地址） React-Router(官方提供的路由插件，通过调用他的api就能解决路由上的问题，单页应用必备),(直接下载一个react-router-dom即可) 是动态路由，纯react组件 常用组件： -&gt; 路由方式, / -&gt; 路由规则, -&gt; 路由选项, -&gt; 跳转导航, / -&gt; 自动跳转， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 class A extends React.Component&#123;constructor(props)&#123; super(props)&#125;render()&#123; return( &lt;div&gt; Component A &lt;Switch&gt; &#x2F;&#x2F;exact 完全匹配，只有等于&#x2F;a时，才跳转。 &lt;Route exact path&#x3D;&#123;&#96;$&#123;this.props.match.path&#125;&#96;&#125; render&#x3D;&#123;(route) &#x3D;&gt; &#123; return &lt;div&gt;当前组件是不带参数的&lt;&#x2F;div&gt; &#125; &#125; &lt;Route path&#x3D;&#123;&#96;$&#123;this.props.match.path&#125;&#x2F;:id&#96;&#125; render&#x3D;&#123;(route) &#x3D;&gt; &#123; return &lt;div&gt; 参数是&#123;route.match.path.id&#125;&lt;&#x2F;div&gt; &#125;&#125;&#x2F;&gt; &lt;&#x2F;Switch&gt; &lt;&#x2F;div&gt; )&#125; &#125; class B extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return( &lt;div&gt; Component B &lt;&#x2F;div&gt; ) &#125; &#125; class Wrapper extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return( &lt;div&gt; &lt;Link to&#x3D;&quot;&#x2F;a&quot;&gt;组件A&lt;&#x2F;Link&gt; &lt;Link to&#x3D;&quot;&#x2F;a&#x2F;123&quot;&gt;带参数的组件A&lt;&#x2F;Link&gt; &lt;Link to&#x3D;&quot;&#x2F;b&quot;&gt;组件B&lt;&#x2F;Link&gt; &#123;this.props.children&#125; &lt;&#x2F;div&gt; ) &#125; &#125; ReactDOM.render(&lt;Router&gt; &lt;Wrapper&gt; &lt;Route path&#x3D;&quot;&#x2F;a&quot; component&#x3D;&#123;A&#125;&#x2F;&gt; &lt;Route path&#x3D;&quot;&#x2F;b&quot; component&#x3D;&#123;B&#125;&#x2F;&gt; &lt;&#x2F;Wrapper&gt;&lt;&#x2F;Router&gt;document.getElementById(&#39;app&#39;) ) React数据管理 依靠状态提升来和兄弟元素进行数据交互 –&gt; 通过父组件完成（通过找到共同的祖先元素，适用于组件层级扁平，兄弟组件通信情况很少的情况，不适合业务层级很深的情况） 通过发布订阅模式做数据交互 –&gt;（观察者模式）：有一个订阅中心，组件A发信息给订阅中心，组件B接收 （业务规模小，层级较深的业务） Redux等数据管理工具 –&gt;组件A发送action给reducer，reducer把state传给store，再由store驱动组件B更改 （适用于业务复杂，组件层级较深，兄弟组件通信密切的项目） redux 一个专门用于做状态管理的JS库（不是react插件库）。与react最适配。管理react应用中多个组件共享的状态 action creator&lt;—— component &lt;—–&gt; store &lt;——&gt; reducer action{type: ,data: ,} reducer(state=0,action) react-redux 一个react插件库，专门用来简化react应用中使用redux 思想：(component) UI组件 里不使用redux的api + 容器组件（container)里使用redux的api Provider:让所有组件都可以得到state数据 接收一个store connect连接store:用于包装UI组件生成容器组件 把state to props，dispatch to props ,传给容器组件 redux异步编程（异步中间件） redux默认是不能进行异步处理的，应用中又需要在redux中执行异步任务，则需要redux异步中间件 actions.js里，返回一个函数（同步的时候返回的是对象） axios 封装 XmlHttpRequest 对象的ajax。promise风格。可以用在浏览器端和node服务器端 react-router react的一个插件库,专门用来实现一个SPA应用（single page web application，单页web应用） SPA应用:整个应用只有一个完整的页面,点击页面中的链接不会刷新页面，本身也不会向服务器发送请求，当点击路由链接时，只会做页面局部的更新,数据都需要通过ajax请求获取 route 路由，一个路由就是一个映射关系，key为路由路径，value可能是function/component（后台路由：value是function，前台路由：value是component） （注册路由：router.get(path,function(req,res))） 前端路由的实现1）histtory库:包装的是原生BOM中window.history和window.location.hash 1.BrowserRouter 2. (a标签的改写) 3. (有两个的话外围再用switch包一下) 4. (默认显示)","categories":[],"tags":[]},{"title":"网站demo (jQuery)","slug":"我的第一篇博客文章","date":"2020-06-02T02:40:43.000Z","updated":"2020-06-03T04:36:25.095Z","comments":true,"path":"2020/06/02/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/06/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"功能模块 登陆功能 为登陆按钮添加点击事件 获取用户在文本框中输入的用户名和密码 验证用户是否输入了用户名和密码，没有则阻止程序向下执行 调用实现登陆功能的接口（ajax），登陆成功，跳转到下一页 登陆拦截 使用script标签加载服务器端提供的接口地址（不用ajax，因为ajax是异步的不会阻止程序向下执行），且还需在最上方 判断isLogin变量， 如果为false，跳转登陆页面 退出功能 为退出按钮添加点击事件 利用confirm方法返回值（当用户点击确定–&gt;true,点击取消—-&gt;false） 当true时调用$.ajax方法(不用传递参数) 添加用户 1.在表单中，为添加的用户的每一项添加name属性，（name属性要和接口文档中要求的参数名称保持一致） 2.为表单绑定提交事件，（在事件处理函数中要阻止表单默认提交的行为） 3.在事件处理函数中获取用户在表单中输入的内容（ serialize()方法: 将内容格式化成参数字符串 ） var formData = $(this).serialize() (formData传到ajax里的data中) 4.调用添加用户的接口，将获取到的内容通过接口发送给服务端，操作成功—&gt;刷新页面，失败–&gt;用户提示 用户头像上传 1.为文件选择控件添加onchange事件，在事件处理函数中获取到用户选择的文件 2.创建formData对象用于实现图片文件上传 (用户选择到的文件为 this.files[0] ) formData 1formData.append(&#39;avatar&#39;,this.files[0]) （将用户的文件上传给服务器端） 3.调用图片文件上传接口($.ajax中设置processData: false //告诉$.ajax不要解析请求参数。因为当前时二进制文件上传，所以不用解析。设置contentType: false //告诉$.ajax方法不要设置请求参数的类型) 4.在添加新用户表单中新增一个隐藏域，将图片地址存储在隐藏域中 &lt;input type=&quot;hidden&quot; name=&quot;avatar&quot; id=&quot;hiddenAvatar&quot;&gt; (name值要跟文档匹配) 5.（服务器返回的是上传的文件的地址）。 在success函数中两件事：1.头像预览$(&#39;#preview&#39;).attr(&#39;src&#39;, response[0].avatar) 2.将图片地址存在隐藏域中$(&#39;#hiddenAvatar&#39;).val(response[0].avatar) (提交给服务器端用) 用户列表展示 (10132967) 1.在页面加载时向服务器发送ajax请求，索要用户列表数据 2.使用模版引擎将数据和html模版拼接 3.将拼接好的内容展现在页面中 用户信息修改 一、通过事件委托的形式为编辑按钮添加点击事件（用户信息修改功能，要把用户信息展示在页面上，因为用ajax向服务器请求的数据不知什么时候返回，所以用事件委托的方式，为他的父级添加点击事件） 在事件处理函数中获取当前点击的用户的ID值 根据用户ID获取用户的详细信息（$.ajax),并通过模版引擎将用户信息渲染在表&gt;单中 二、为提交按钮添加点击事件。（也要用事件委托的形式）1.获取用户在表单中&gt;输入的内容，2.调用修改用户信息接口实现用户信息修改功能（$.ajax）,success函数里location.reload(),刷新页面(下面的意思是当点击’edit’类的时候，触发冒泡机制，触发userBox的点击事件的处理函数)$(&#39;#userBox&#39;).on(&#39;click&#39;, &#39;.edit&#39;, function () {} 删除用户 为删除按钮添加点击事件（事件委托的方法） 确认用户是否要进行删除（confirm方法） 获取当前被点击的用户的ID 调用删除用户接口根据ID删除用户，成功—&gt;刷新页面 第二章","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}